PERLTIDY(1)                               User Contributed Perl Documentation                               PERLTIDY(1)

NNAAMMEE
       perltidy - a perl script indenter and reformatter

SSYYNNOOPPSSIISS
           perltidy [ options ] file1 file2 file3 ...
                   (output goes to file1.tdy, file2.tdy, file3.tdy, ...)
           perltidy [ options ] file1 -o outfile
           perltidy [ options ] file1 -st >outfile
           perltidy [ options ] <infile >outfile

DDEESSCCRRIIPPTTIIOONN
       Perltidy reads a perl script and writes an indented, reformatted script.

       Many users will find enough information in "EXAMPLES" to get started.  New users may benefit from the short
       tutorial which can be found at http://perltidy.sourceforge.net/tutorial.html

       A convenient aid to systematically defining a set of style parameters can be found at
       http://perltidy.sourceforge.net/stylekey.html

       Perltidy can produce output on either of two modes, depending on the existence of an --hhttmmll flag.  Without this
       flag, the output is passed through a formatter.  The default formatting tries to follow the recommendations in
       ppeerrllssttyyllee(1), but it can be controlled in detail with numerous input parameters, which are described in
       "FORMATTING OPTIONS".

       When the --hhttmmll flag is given, the output is passed through an HTML formatter which is described in "HTML
       OPTIONS".

EEXXAAMMPPLLEESS
         perltidy somefile.pl

       This will produce a file _s_o_m_e_f_i_l_e_._p_l_._t_d_y containing the script reformatted using the default options, which
       approximate the style suggested in ppeerrllssttyyllee(1).  The source file _s_o_m_e_f_i_l_e_._p_l is unchanged.

         perltidy *.pl

       Execute perltidy on all _._p_l files in the current directory with the default options.  The output will be in
       files with an appended _._t_d_y extension.  For any file with an error, there will be a file with extension _._E_R_R.

         perltidy -b file1.pl file2.pl

       Modify _f_i_l_e_1_._p_l and _f_i_l_e_2_._p_l in place, and backup the originals to _f_i_l_e_1_._p_l_._b_a_k and _f_i_l_e_2_._p_l_._b_a_k.  If
       _f_i_l_e_1_._p_l_._b_a_k and/or _f_i_l_e_2_._p_l_._b_a_k already exist, they will be overwritten.

         perltidy -b -bext='/' file1.pl file2.pl

       Same as the previous example except that the backup files _f_i_l_e_1_._p_l_._b_a_k and _f_i_l_e_2_._p_l_._b_a_k will be deleted if there
       are no errors.

         perltidy -gnu somefile.pl

       Execute perltidy on file _s_o_m_e_f_i_l_e_._p_l with a style which approximates the GNU Coding Standards for C programs.
       The output will be _s_o_m_e_f_i_l_e_._p_l_._t_d_y.

         perltidy -i=3 somefile.pl

       Execute perltidy on file _s_o_m_e_f_i_l_e_._p_l, with 3 columns for each level of indentation (--ii==33) instead of the default
       4 columns.  There will not be any tabs in the reformatted script, except for any which already exist in
       comments, pod documents, quotes, and here documents.  Output will be _s_o_m_e_f_i_l_e_._p_l_._t_d_y.

         perltidy -i=3 -et=8 somefile.pl

       Same as the previous example, except that leading whitespace will be entabbed with one tab character per 8
       spaces.

         perltidy -ce -l=72 somefile.pl

       Execute perltidy on file _s_o_m_e_f_i_l_e_._p_l with all defaults except use "cuddled elses" (--ccee) and a maximum line
       length of 72 columns (--ll==7722) instead of the default 80 columns.

         perltidy -g somefile.pl

       Execute perltidy on file _s_o_m_e_f_i_l_e_._p_l and save a log file _s_o_m_e_f_i_l_e_._p_l_._L_O_G which shows the nesting of braces,
       parentheses, and square brackets at the start of every line.

         perltidy -html somefile.pl

       This will produce a file _s_o_m_e_f_i_l_e_._p_l_._h_t_m_l containing the script with html markup.  The output file will contain
       an embedded style sheet in the <HEAD> section which may be edited to change the appearance.

         perltidy -html -css=mystyle.css somefile.pl

       This will produce a file _s_o_m_e_f_i_l_e_._p_l_._h_t_m_l containing the script with html markup.  This output file will contain
       a link to a separate style sheet file _m_y_s_t_y_l_e_._c_s_s.  If the file _m_y_s_t_y_l_e_._c_s_s does not exist, it will be created.
       If it exists, it will not be overwritten.

         perltidy -html -pre somefile.pl

       Write an html snippet with only the PRE section to _s_o_m_e_f_i_l_e_._p_l_._h_t_m_l.  This is useful when code snippets are
       being formatted for inclusion in a larger web page.  No style sheet will be written in this case.

         perltidy -html -ss >mystyle.css

       Write a style sheet to _m_y_s_t_y_l_e_._c_s_s and exit.

         perltidy -html -frm mymodule.pm

       Write html with a frame holding a table of contents and the source code.  The output files will be
       _m_y_m_o_d_u_l_e_._p_m_._h_t_m_l (the frame), _m_y_m_o_d_u_l_e_._p_m_._t_o_c_._h_t_m_l (the table of contents), and _m_y_m_o_d_u_l_e_._p_m_._s_r_c_._h_t_m_l (the source
       code).

OOPPTTIIOONNSS -- OOVVEERRVVIIEEWW
       The entire command line is scanned for options, and they are processed before any files are processed.  As a
       result, it does not matter whether flags are before or after any filenames.  However, the relative order of
       parameters is important, with later parameters overriding the values of earlier parameters.

       For each parameter, there is a long name and a short name.  The short names are convenient for keyboard input,
       while the long names are self-documenting and therefore useful in scripts.  It is customary to use two leading
       dashes for long names, but one may be used.

       Most parameters which serve as on/off flags can be negated with a leading "n" (for the short name) or a leading
       "no" or "no-" (for the long name).  For example, the flag to outdent long quotes is --oollqq or
       ----oouuttddeenntt--lloonngg--qquuootteess.  The flag to skip this is --nnoollqq or ----nnoooouuttddeenntt--lloonngg--qquuootteess or ----nnoo--oouuttddeenntt--lloonngg--qquuootteess.

       Options may not be bundled together.  In other words, options --qq and --gg may NOT be entered as --qqgg.

       Option names may be terminated early as long as they are uniquely identified.  For example, instead of
       ----dduummpp--ttookkeenn--ttyyppeess, it would be sufficient to enter ----dduummpp--ttookk, or even ----dduummpp--tt, to uniquely identify this
       command.

   II//OO ccoonnttrrooll
       The following parameters concern the files which are read and written.

       --hh,    ----hheellpp
           Show summary of usage and exit.

       --oo=filename,    ----oouuttffiillee=filename
           Name of the output file (only if a single input file is being processed).  If no output file is specified,
           and output is not redirected to the standard output (see --sstt), the output will go to _f_i_l_e_n_a_m_e_._t_d_y. [Note: -
           does not redirect to standard output. Use --sstt instead.]

       --sstt,    ----ssttaannddaarrdd--oouuttppuutt
           Perltidy must be able to operate on an arbitrarily large number of files in a single run, with each output
           being directed to a different output file.  Obviously this would conflict with outputting to the single
           standard output device, so a special flag, --sstt, is required to request outputting to the standard output.
           For example,

             perltidy somefile.pl -st >somefile.new.pl

           This option may only be used if there is just a single input file.  The default is --nnsstt or
           ----nnoossttaannddaarrdd--oouuttppuutt.

       --ssee,    ----ssttaannddaarrdd--eerrrroorr--oouuttppuutt
           If perltidy detects an error when processing file _s_o_m_e_f_i_l_e_._p_l, its default behavior is to write error
           messages to file _s_o_m_e_f_i_l_e_._p_l_._E_R_R.  Use --ssee to cause all error messages to be sent to the standard error
           output stream instead.  This directive may be negated with --nnssee.  Thus, you may place --ssee in a _._p_e_r_l_t_i_d_y_r_c
           and override it when desired with --nnssee on the command line.

       --ooeexxtt=ext,    ----oouuttppuutt--ffiillee--eexxtteennssiioonn=ext
           Change the extension of the output file to be _e_x_t instead of the default _t_d_y (or _h_t_m_l in case the ---hhttmmll
           option is used).  See "Specifying File Extensions".

       --ooppaatthh=path,    ----oouuttppuutt--ppaatthh=path
           When perltidy creates a filename for an output file, by default it merely appends an extension to the path
           and basename of the input file.  This parameter causes the path to be changed to _p_a_t_h instead.

           The path should end in a valid path separator character, but perltidy will try to add one if it is missing.

           For example

            perltidy somefile.pl -opath=/tmp/

           will produce _/_t_m_p_/_s_o_m_e_f_i_l_e_._p_l_._t_d_y.  Otherwise, _s_o_m_e_f_i_l_e_._p_l_._t_d_y will appear in whatever directory contains
           _s_o_m_e_f_i_l_e_._p_l.

           If the path contains spaces, it should be placed in quotes.

           This parameter will be ignored if output is being directed to standard output, or if it is being specified
           explicitly with the --oo==ss parameter.

       --bb,    ----bbaacckkuupp--aanndd--mmooddiiffyy--iinn--ppllaaccee
           Modify the input file or files in-place and save the original with the extension _._b_a_k.  Any existing _._b_a_k
           file will be deleted.  See next item for changing the default backup extension, and for eliminating the
           backup file altogether.

           A --bb flag will be ignored if input is from standard input or goes to standard output, or if the --hhttmmll flag
           is set.

           In particular, if you want to use both the --bb flag and the --ppbbpp (--perl-best-practices) flag, then you must
           put a --nnsstt flag after the --ppbbpp flag because it contains a --sstt flag as one of its components, which means
           that output will go to the standard output stream.

       --bbeexxtt=ext,    ----bbaacckkuupp--ffiillee--eexxtteennssiioonn=ext
           This parameter serves two purposes: (1) to change the extension of the backup file to be something other
           than the default _._b_a_k, and (2) to indicate that no backup file should be saved.

           To change the default extension to something other than _._b_a_k see "Specifying File Extensions".

           A backup file of the source is always written, but you can request that it be deleted at the end of
           processing if there were no errors.  This is risky unless the source code is being maintained with a source
           code control system.

           To indicate that the backup should be deleted include one forward slash, //, in the extension.  If any text
           remains after the slash is removed it will be used to define the backup file extension (which is always
           created and only deleted if there were no errors).

           Here are some examples:

             Parameter           Extension          Backup File Treatment
             <-bext=bak>         F<.bak>            Keep (same as the default behavior)
             <-bext='/'>         F<.bak>            Delete if no errors
             <-bext='/backup'>   F<.backup>         Delete if no errors
             <-bext='original/'> F<.original>       Delete if no errors

       --ww,    ----wwaarrnniinngg--oouuttppuutt
           Setting --ww causes any non-critical warning messages to be reported as errors.  These include messages about
           possible pod problems, possibly bad starting indentation level, and cautions about indirect object usage.
           The default, --nnww or ----nnoowwaarrnniinngg--oouuttppuutt, is not to include these warnings.

       --qq,    ----qquuiieett
           Deactivate error messages (for running under an editor).

           For example, if you use a vi-style editor, such as vim, you may execute perltidy as a filter from within the
           editor using something like

            :n1,n2!perltidy -q

           where "n1,n2" represents the selected text.  Without the --qq flag, any error message may mess up your screen,
           so be prepared to use your "undo" key.

       --lloogg,    ----llooggffiillee
           Save the _._L_O_G file, which has many useful diagnostics.  Perltidy always creates a _._L_O_G file, but by default
           it is deleted unless a program bug is suspected.  Setting the --lloogg flag forces the log file to be saved.

       --gg==nn, ----llooggffiillee--ggaapp==nn
           Set maximum interval between input code lines in the logfile.  This purpose of this flag is to assist in
           debugging nesting errors.  The value of "n" is optional.  If you set the flag --gg without the value of "n",
           it will be taken to be 1, meaning that every line will be written to the log file.  This can be helpful if
           you are looking for a brace, paren, or bracket nesting error.

           Setting --gg also causes the logfile to be saved, so it is not necessary to also include --lloogg.

           If no --gg flag is given, a value of 50 will be used, meaning that at least every 50th line will be recorded
           in the logfile.  This helps prevent excessively long log files.

           Setting a negative value of "n" is the same as not setting --gg at all.

       --nnpprroo  ----nnoopprrooffiillee
           Ignore any _._p_e_r_l_t_i_d_y_r_c command file.  Normally, perltidy looks first in your current directory for a
           _._p_e_r_l_t_i_d_y_r_c file of parameters.  (The format is described below).  If it finds one, it applies those options
           to the initial default values, and then it applies any that have been defined on the command line.  If no
           _._p_e_r_l_t_i_d_y_r_c file is found, it looks for one in your home directory.

           If you set the --nnpprroo flag, perltidy will not look for this file.

       --pprroo==ffiilleennaammee or  ----pprrooffiillee==ffiilleennaammee
           To simplify testing and switching .perltidyrc files, this command may be used to specify a configuration
           file which will override the default name of .perltidyrc.  There must not be a space on either side of the
           '=' sign.  For example, the line

              perltidy -pro=testcfg

           would cause file _t_e_s_t_c_f_g to be used instead of the default _._p_e_r_l_t_i_d_y_r_c.

           A pathname begins with three dots, e.g. ".../.perltidyrc", indicates that the file should be searched for
           starting in the current directory and working upwards. This makes it easier to have multiple projects each
           with their own .perltidyrc in their root directories.

       --oopptt,   ----sshhooww--ooppttiioonnss
           Write a list of all options used to the _._L_O_G file.  Please see ----dduummpp--ooppttiioonnss for a simpler way to do this.

       --ff,   ----ffoorrccee--rreeaadd--bbiinnaarryy
           Force perltidy to process binary files.  To avoid producing excessive error messages, perltidy skips files
           identified by the system as non-text.  However, valid perl scripts containing binary data may sometimes be
           identified as non-text, and this flag forces perltidy to process them.

       --aasstt,   ----aasssseerrtt--ttiiddyy
           This flag asserts that the input and output code streams are identical, or in other words that the input
           code is already 'tidy' according to the formatting parameters.  If this is not the case, an error message
           noting this is produced.  This error message will cause the process to return a non-zero exit code.  The
           test for this is made by comparing an MD5 hash value for the input and output code streams. This flag has no
           other effect on the functioning of perltidy.  This might be useful for certain code maintenance operations.
           Note: you will not see this message if you have error messages turned off with the -quiet flag.

       --aassuu,   ----aasssseerrtt--uunnttiiddyy
           This flag asserts that the input and output code streams are different, or in other words that the input
           code is 'untidy' according to the formatting parameters.  If this is not the case, an error message noting
           this is produced.  This flag has no other effect on the functioning of perltidy.

       --ssaall==ss,   ----ssuubb--aalliiaass--lliisstt==ss
           This flag causes one or more words to be treated the same as if they were the keyword 'sub'.  The string ss
           contains one or more alias words, separated by spaces or commas.

           For example,

                   perltidy -sal='method fun _sub M4'

           will cause the perltidy to treate the words 'method', 'fun', '_sub' and 'M4' to be treated the same as if
           they were 'sub'.  Note that if the alias words are separated by spaces then the string of words should be
           placed in quotes.

           Note that several other parameters accept a list of keywords, including 'sub' (see "Specifying Block
           Types").  You do not need to include any sub aliases in these lists. Just include keyword 'sub' if you wish,
           and all aliases are automatically included.

FFOORRMMAATTTTIINNGG OOPPTTIIOONNSS
   BBaassiicc OOppttiioonnss
       ----nnoottiiddyy
           This flag disables all formatting and causes the input to be copied unchanged to the output except for
           possible changes in line ending characters and any pre- and post-filters.  This can be useful in conjunction
           with a hierarchical set of _._p_e_r_l_t_i_d_y_r_c files to avoid unwanted code tidying.  See also "Skipping Selected
           Sections of Code" for a way to avoid tidying specific sections of code.

       --ii==nn,  ----iinnddeenntt--ccoolluummnnss==nn
           Use n columns per indentation level (default n=4).

       --ll==nn, ----mmaaxxiimmuumm--lliinnee--lleennggtthh==nn
           The default maximum line length is n=80 characters.  Perltidy will try to find line break points to keep
           lines below this length. However, long quotes and side comments may cause lines to exceed this length.

           The default length of 80 comes from the past when this was the standard CRT screen width.  Many programmers
           prefer to increase this to something like 120.

           Setting --ll==00 is equivalent to setting --ll==((aa vveerryy llaarrggee nnuummbbeerr)).  But this is not recommended because, for
           example, a very long list will be formatted in a single long line.

       --vvmmllll, ----vvaarriiaabbllee--mmaaxxiimmuumm--lliinnee--lleennggtthh
           A problem arises using a fixed maximum line length with very deeply nested code and data structures because
           eventually the amount of leading whitespace used for indicating indentation takes up most or all of the
           available line width, leaving little or no space for the actual code or data.  One solution is to use a vary
           long line length.  Another solution is to use the --vvmmllll flag, which basically tells perltidy to ignore
           leading whitespace when measuring the line length.

           To be precise, when the --vvmmllll parameter is set, the maximum line length of a line of code will be M+L*I,
           where

                 M is the value of --maximum-line-length=M (-l=M), default 80,
                 I is the value of --indent-columns=I (-i=I), default 4,
                 L is the indentation level of the line of code

           When this flag is set, the choice of breakpoints for a block of code should be essentially independent of
           its nesting depth.  However, the absolute line lengths, including leading whitespace, can still be
           arbitrarily large.  This problem can be avoided by including the next parameter.

           The default is not to do this (--nnvvmmllll).

       --wwcc==nn, ----wwhhiitteessppaaccee--ccyyccllee==nn
           This flag also addresses problems with very deeply nested code and data structures.  When the nesting depth
           exceeds the value nn the leading whitespace will be reduced and start at a depth of 1 again.  The result is
           that blocks of code will shift back to the left rather than moving arbitrarily far to the right.  This
           occurs cyclically to any depth.

           For example if one level of indentation equals 4 spaces (--ii==44, the default), and one uses --wwcc==1155, then if
           the leading whitespace on a line exceeds about 4*15=60 spaces it will be reduced back to 4*1=4 spaces and
           continue increasing from there.  If the whitespace never exceeds this limit the formatting remains
           unchanged.

           The combination of --vvmmllll and --wwcc==nn provides a solution to the problem of displaying arbitrarily deep data
           structures and code in a finite window, although --wwcc==nn may of course be used without --vvmmllll.

           The default is not to use this, which can also be indicated using --wwcc==00.

       TTaabbss
           Using tab characters will almost certainly lead to future portability and maintenance problems, so the
           default and recommendation is not to use them.  For those who prefer tabs, however, there are two different
           options.

           Except for possibly introducing tab indentation characters, as outlined below, perltidy does not introduce
           any tab characters into your file, and it removes any tabs from the code (unless requested not to do so with
           --ffwwss).  If you have any tabs in your comments, quotes, or here-documents, they will remain.

           --eett==nn,   ----eennttaabb--lleeaaddiinngg--wwhhiitteessppaaccee
               This flag causes each nn initial space characters to be replaced by one tab character.

               The value of the integer nn can be any value but can be coordinated with the number of spaces used for
               intentation. For example, --eett==44 --ccii==44 --ii==44 will produce one tab for each indentation level and and one
               for each continuation indentation level.  You may want to coordinate the value of nn with what your
               display software assumes for the spacing of a tab.

           --tt,   ----ttaabbss
               This flag causes one leading tab character to be inserted for each level of indentation.  Certain other
               features are incompatible with this option, and if these options are also given, then a warning message
               will be issued and this flag will be unset.  One example is the --llpp option. This flag is retained for
               backwards compatibility, but if you use tabs, the --eett==nn flag is recommended.

           --ddtt==nn,   ----ddeeffaauulltt--ttaabbssiizzee==nn
               If the first line of code passed to perltidy contains leading tabs but no tab scheme is specified for
               the output stream then perltidy must guess how many spaces correspond to each leading tab.  This number
               of spaces nn corresponding to each leading tab of the input stream may be specified with --ddtt==nn.  The
               default is nn==88.

               This flag has no effect if a tab scheme is specified for the output stream, because then the input
               stream is assumed to use the same tab scheme and indentation spaces as for the output stream (any other
               assumption would lead to unstable editing).

       --xxss,   ----eexxtteennddeedd--ssyynnttaaxx
           A problem with formatting Perl code is that some modules can introduce new syntax.  This flag allows
           perltidy to handle certain common extensions to the standard syntax without complaint.

           For example, without this flag a structure such as the following would generate a syntax error and the
           braces would not be balanced:

               method deposit( Num $amount) {
                   $self->balance( $self->balance + $amount );
               }

           For one of the extensions, module Switch::Plain, colons are marked as labels.  If you use this module, you
           may want to also use the ----nnoooouuttddeenntt--llaabbeellss flag to prevent lines such as 'default:' from being outdented.

           This flag is enabled by default but it can be deactivated with --nnxxss.  Probably the only reason to deactivate
           this flag is to generate more diagnostic messages when debugging a script.

           For another method of handling extended syntax see the section "Skipping Selected Sections of Code".

       --iioo,   ----iinnddeenntt--oonnllyy
           This flag is used to deactivate all whitespace and line break changes within non-blank lines of code.  When
           it is in effect, the only change to the script will be to the indentation and to the number of blank lines.
           And any flags controlling whitespace and newlines will be ignored.  You might want to use this if you are
           perfectly happy with your whitespace and line breaks, and merely want perltidy to handle the indentation.
           (This also speeds up perltidy by well over a factor of two, so it might be useful when perltidy is merely
           being used to help find a brace error in a large script).

           Setting this flag is equivalent to setting ----ffrreeeezzee--nneewwlliinneess and ----ffrreeeezzee--wwhhiitteessppaaccee.

           If you also want to keep your existing blank lines exactly as they are, you can add ----ffrreeeezzee--bbllaannkk--lliinneess.

           With this option perltidy is still free to modify the indenting (and outdenting) of code and comments as it
           normally would.  If you also want to prevent long comment lines from being outdented, you can add either
           --nnoollll or --ll==00.

           Setting this flag will prevent perltidy from doing any special operations on closing side comments.  You may
           still delete all side comments however when this flag is in effect.

       --eenncc==ss,  ----cchhaarraacctteerr--eennccooddiinngg==ss
           This flag indicates the character encoding, if any, of the input data stream.  Perltidy does not look for
           the encoding directives in the soure stream, such as uussee uuttff88, and instead relies on this flag to determine
           the encoding.  (Note that perltidy often works on snippets of code rather than complete files so it cannot
           rely on uussee uuttff88 directives).

           The possible values for ss are (1) the name of an encoding recognized by the Encode.pm module, (2) nnoonnee if no
           encoding is used, or (3) <guess> if perltidy should guess.

           For example, the value uuttff88 causes the stream to be read and written as UTF-8.  If the input stream cannot
           be decoded with a specified encoding then processing is not done.

           The value nnoonnee causes the stream to be processed without special encoding assumptions.  This is appropriate
           for files which are written in single-byte character encodings such as latin-1.

           The value gguueessss tells perltidy to guess between either utf8 encoding or no encoding (meaning one character
           per byte).  The guess uses the Encode::Guess module and this restricted range of guesses covers the most
           common cases.  Testing showed that considering any greater number of encodings as guess suspects is too
           risky.

           The current default is gguueessss.

           The abbreviations --uuttff88 or --UUTTFF88 are equivalent to --eenncc==uuttff88, and the abbreviation --gguueessss is equivalent to
           <-enc=guess>.  So to process a file named ffiillee..ppll which is encoded in UTF-8 you can use:

              perltidy -utf8 file.pl

           or
              perltidy -guess file.pl

           To process a file in eeuucc--jjpp you could use

              perltidy -enc=euc-jp file.pl

           A perltidy output file is unencoded if the input file is unencoded, and otherwise it is encoded as uuttff88,
           even if the input encoding was not uuttff88.

       --ggccss,  ----uussee--uunniiccooddee--ggccssttrriinngg
           This flag controls whether or not perltidy may use module Unicode::GCString to obtain accurate display
           widths of wide characters.  The default is ----nnoouussee--uunniiccooddee--ggccssttrriinngg.

           If this flag is set, and text is encoded, perltidy will look for the module Unicode::GCString and, if found,
           will use it to obtain character display widths.  This can improve displayed vertical alignment for files
           with wide characters.  It is a nice feature but it is off by default to avoid conflicting formatting when
           there are multiple developers.  Perltidy installation does not require Unicode::GCString, so users wanting
           to use this feature need set this flag and also to install Unicode::GCString separately.

           If this flag is set and perltidy does not find module Unicode::GCString, a warning message will be produced
           and processing will continue but without the potential benefit provided by the module.

           Also note that actual vertical alignment depends upon the fonts used by the text display software, so
           vertical alignment may not be optimal even when Unicode::GCString is used.

       --oollee==ss,  ----oouuttppuutt--lliinnee--eennddiinngg==ss
           where s="win", "dos", "unix", or "mac".  This flag tells perltidy to output line endings for a specific
           system.  Normally, perltidy writes files with the line separator character of the host system.  The "win"
           and "dos" flags have an identical result.

       --ppllee,  ----pprreesseerrvvee--lliinnee--eennddiinnggss
           This flag tells perltidy to write its output files with the same line endings as the input file, if
           possible.  It should work for ddooss, uunniixx, and mmaacc line endings.  It will only work if perltidy input comes
           from a filename (rather than stdin, for example).  If perltidy has trouble determining the input file line
           ending, it will revert to the default behavior of using the line ending of the host system.

       --aattnnll,  ----aadddd--tteerrmmiinnaall--nneewwlliinnee
           This flag, which is enabled by default, allows perltidy to terminate the last line of the output stream with
           a newline character, regardless of whether or not the input stream was terminated with a newline character.
           If this flag is negated, with --nnaattnnll, then perltidy will add a terminal newline to the the output stream
           only if the input stream is terminated with a newline.

           Negating this flag may be useful for manipulating one-line scripts intended for use on a command line.

       --iitt==nn,   ----iitteerraattiioonnss==nn
           This flag causes perltidy to do nn complete iterations.  The reason for this flag is that code beautification
           is an iterative process and in some cases the output from perltidy can be different if it is applied a
           second time.  For most purposes the default of nn==11 should be satisfactory.  However nn==22 can be useful when a
           major style change is being made, or when code is being beautified on check-in to a source code control
           system.  It has been found to be extremely rare for the output to change after 2 iterations.  If a value nn
           is greater than 2 is input then a convergence test will be used to stop the iterations as soon as possible,
           almost always after 2 iterations.  See the next item for a simplified iteration control.

           This flag has no effect when perltidy is used to generate html.

       --ccoonnvv,   ----ccoonnvveerrggee
           This flag is equivalent to --iitt==44 and is included to simplify iteration control.  For all practical purposes
           one either does or does not want to be sure that the output is converged, and there is no penalty to using a
           large iteration limit since perltidy will check for convergence and stop iterating as soon as possible.  The
           default is --nnccoonnvv (no convergence check).  Using --ccoonnvv will approximately double run time since typically
           one extra iteration is required to verify convergence.  No extra iterations are required if no new line
           breaks are made, and two extra iterations are occasionally needed when reformatting complex code structures,
           such as deeply nested ternary statements.

   CCooddee IInnddeennttaattiioonn CCoonnttrrooll
       --ccii==nn, ----ccoonnttiinnuuaattiioonn--iinnddeennttaattiioonn==nn
           Continuation indentation is extra indentation spaces applied when a long line is broken.  The default is
           n=2, illustrated here:

            my $level =   # -ci=2
              ( $max_index_to_go >= 0 ) ? $levels_to_go[0] : $last_output_level;

           The same example, with n=0, is a little harder to read:

            my $level =   # -ci=0
            ( $max_index_to_go >= 0 ) ? $levels_to_go[0] : $last_output_level;

           The value given to --ccii is also used by some commands when a small space is required.  Examples are commands
           for outdenting labels, --oollaa, and control keywords, --ookkww.

           When default values are not used, it is recommended that either

           (1) the value nn given with --ccii==nn be no more than about one-half of the number of spaces assigned to a full
           indentation level on the --ii==nn command, or

           (2) the flag --eexxtteennddeedd--ccoonnttiinnuuaattiioonn--iinnddeennttaattiioonn is used (see next section).

       --xxccii, ----eexxtteennddeedd--ccoonnttiinnuuaattiioonn--iinnddeennttaattiioonn
           This flag allows perltidy to use some improvements which have been made to its indentation model. One of the
           things it does is "extend" continuation indentation deeper into structures, hence the name.  The improved
           indentation is particularly noticeable when the flags --ccii==nn and --ii==nn use the same value of nn. There are no
           significant disadvantages to using this flag, but to avoid disturbing existing formatting the default is not
           to use it, --nnxxccii.

           Please see the section "--ppbbpp, ----ppeerrll--bbeesstt--pprraaccttiicceess" for an example of how this flag can improve the
           formatting of ternary statements.  It can also improve indentation of some multi-line qw lists as shown
           below.

                       # perltidy
                       foreach $color (
                           qw(
                           AntiqueWhite3 Bisque1 Bisque2 Bisque3 Bisque4
                           SlateBlue3 RoyalBlue1 SteelBlue2 DeepSkyBlue3
                           ),
                           qw(
                           LightBlue1 DarkSlateGray1 Aquamarine2 DarkSeaGreen2
                           SeaGreen1 Yellow1 IndianRed1 IndianRed2 Tan1 Tan4
                           )
                         )

                       # perltidy -xci
                       foreach $color (
                           qw(
                               AntiqueWhite3 Bisque1 Bisque2 Bisque3 Bisque4
                               SlateBlue3 RoyalBlue1 SteelBlue2 DeepSkyBlue3
                           ),
                           qw(
                               LightBlue1 DarkSlateGray1 Aquamarine2 DarkSeaGreen2
                               SeaGreen1 Yellow1 IndianRed1 IndianRed2 Tan1 Tan4
                           )
                         )

       --ssiill==nn ----ssttaarrttiinngg--iinnddeennttaattiioonn--lleevveell==nn
           By default, perltidy examines the input file and tries to determine the starting indentation level.  While
           it is often zero, it may not be zero for a code snippet being sent from an editing session.

           To guess the starting indentation level perltidy simply assumes that indentation scheme used to create the
           code snippet is the same as is being used for the current perltidy process.  This is the only sensible guess
           that can be made.  It should be correct if this is true, but otherwise it probably won't.  For example, if
           the input script was written with -i=2 and the current peltidy flags have -i=4, the wrong initial
           indentation will be guessed for a code snippet which has non-zero initial indentation. Likewise, if an
           entabbing scheme is used in the input script and not in the current process then the guessed indentation
           will be wrong.

           If the default method does not work correctly, or you want to change the starting level, use --ssiill==nn, to
           force the starting level to be n.

       LLiisstt iinnddeennttaattiioonn using --llpp, ----lliinnee--uupp--ppaarreenntthheesseess
           By default, perltidy indents lists with 4 spaces, or whatever value is specified with --ii==nn.  Here is a small
           list formatted in this way:

               # perltidy (default)
               @month_of_year = (
                   'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
               );

           Use the --llpp flag to add extra indentation to cause the data to begin past the opening parentheses of a sub
           call or list, or opening square bracket of an anonymous array, or opening curly brace of an anonymous hash.
           With this option, the above list would become:

               # perltidy -lp
               @month_of_year = (
                                  'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                                  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
               );

           If the available line length (see --ll==nn ) does not permit this much space, perltidy will use less.   For
           alternate placement of the closing paren, see the next section.

           This option has no effect on code BLOCKS, such as if/then/else blocks, which always use whatever is
           specified with --ii==nn.

           In situations where perltidy does not have complete freedom to choose line breaks it may temporarily revert
           to its default indentation method.  This can occur for example if there are blank lines, block comments,
           multi-line quotes, or side comments between the opening and closing parens, braces, or brackets.

           In addition, any parameter which significantly restricts the ability of perltidy to choose newlines will
           conflict with --llpp and will cause --llpp to be deactivated.  These include --iioo, --ffnnll, --nnaannll, and --nnddnnll.  The
           reason is that the --llpp indentation style can require the careful coordination of an arbitrary number of
           break points in hierarchical lists, and these flags may prevent that.

           The --llpp option may not be used together with the --tt tabs option.  It may, however, be used with the --eett==nn
           tab method.

       --llppxxll==ss,  ----lliinnee--uupp--ppaarreenntthheesseess--eexxcclluussiioonn--lliisstt
           This is an experimental parameter; the details might change as experience with it is gained.

           The --llpp indentation style works well for some types of coding but can produce very long lines when variables
           have long names and/or containers are very deeply nested.  The --llppxxll==ss flag is intended to help mitigate
           this problem by providing control over the containers to which the --llpp indentation style is applied.  The
           --llpp flag by default is "greedy" and applies to as many containers as possible.  This flag specifies a list
           of things which should nnoott be use --llpp indentation.

           This list is a string with space-separated items.  Each item consists of up to three pieces of information
           in this order: (1) an optional letter code (2) a required container type, and (3) an optional numeric code.

           The only required piece of information is a container type, which is one of '(', '[', or '{'.  For example
           the string

             -lpxl='[ {'

           means do NNOOTT include use -lp formatting within square-bracets or braces.  The only unspecified container is
           '(', so this string means that only the contents within parens will use -lp indentation.

           An optional numeric code may follow any of the container types to further refine the selection based on
           container contents.  The numeric codes are:

             '0' or blank: no check on contents
             '1' reject -lp unless the contents is a simple list without sublists
             '2' reject -lp unless the contents is a simple list without sublists, without
                 code blocks, and without ternary operators

           For example,

             -lpxl = '[ { (2'

           means only apply -lp to parenthesized lists which do not contain any sublists, code blocks or ternary
           expressions.

           A third optional item of information which can be given for parens is an alphanumeric letter which is used
           to limit the selection further depending on the type of token immediately before the paren.  The possible
           letters are currently 'k', 'K', 'f', 'F', 'w', and 'W', with these meanings:

            'k' matches if the previous nonblank token is a perl builtin keyword (such as 'if', 'while'),
            'K' matches if 'k' does not, meaning that the previous token is not a keyword.
            'f' matches if the previous token is a function other than a keyword.
            'F' matches if 'f' does not.
            'w' matches if either 'k' or 'f' match.
            'W' matches if 'w' does not.

           For example,

             -lpxl = '[ { F(2'

           means only apply -lp to parenthesized lists which follow a function call and which do not contain any
           sublists, code blocks or ternary expressions.  The logic of writing these codes is somewhat counter-
           intuitive because they describe what is not getting the -lp indentation.  So the 'F' indicates that non-
           function calls are not getting -lp, or in other words that function calls are getting the -lp indentation.

       --ccttii==nn, ----cclloossiinngg--ttookkeenn--iinnddeennttaattiioonn
           The --ccttii==nn flag controls the indentation of a line beginning with a ")", "]", or a non-block "}".  Such a
           line receives:

            -cti = 0 no extra indentation (default)
            -cti = 1 extra indentation such that the closing token
                   aligns with its opening token.
            -cti = 2 one extra indentation level if the line looks like:
                   );  or  ];  or  };
            -cti = 3 one extra indentation level always

           The flags --ccttii==11 and --ccttii==22 work well with the --llpp flag (previous section).

               # perltidy -lp -cti=1
               @month_of_year = (
                                  'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                                  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
                                );

               # perltidy -lp -cti=2
               @month_of_year = (
                                  'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                                  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'
                                  );

           These flags are merely hints to the formatter and they may not always be followed.  In particular, if -lp is
           not being used, the indentation for ccttii==11 is constrained to be no more than one indentation level.

           If desired, this control can be applied independently to each of the closing container token types.  In
           fact, --ccttii==nn is merely an abbreviation for --ccppii==nn --ccssbbii==nn --ccbbii==nn, where: --ccppii or ----cclloossiinngg--ppaarreenn--iinnddeennttaattiioonn
           controls ))'s, --ccssbbii or ----cclloossiinngg--ssqquuaarree--bbrraacckkeett--iinnddeennttaattiioonn controls ]]'s, --ccbbii or
           ----cclloossiinngg--bbrraaccee--iinnddeennttaattiioonn controls non-block }}'s.

       --iiccpp, ----iinnddeenntt--cclloossiinngg--ppaarreenn
           The --iiccpp flag is equivalent to --ccttii==22, described in the previous section.  The --nniiccpp flag is equivalent
           --ccttii==00.  They are included for backwards compatibility.

       --iiccbb, ----iinnddeenntt--cclloossiinngg--bbrraaccee
           The --iiccbb option gives one extra level of indentation to a brace which terminates a code block .  For
           example,

                   if ($task) {
                       yyy();
                       }    # -icb
                   else {
                       zzz();
                       }

           The default is not to do this, indicated by --nniiccbb.

       --nniibb, ----nnoonn--iinnddeennttiinngg--bbrraacceess
           Normally, lines of code contained within a pair of block braces receive one additional level of indentation.
           This flag, which is enabled by default, causes perltidy to look for opening block braces which are followed
           by a special side comment. This special side comment is ##<<<<<< by default.  If found, the code between this
           opening brace and its corresponding closing brace will not be given the normal extra indentation level.  For
           example:

                       { #<<<   a closure to contain lexical vars

                       my $var;  # this line does not get one level of indentation
                       ...

                       }

                       # this line does not 'see' $var;

           This can be useful, for example, when combining code from different files.  Different sections of code can
           be placed within braces to keep their lexical variables from being visible to the end of the file.  To keep
           the new braces from causing all of their contained code to be indented if you run perltidy, and possibly
           introducing new line breaks in long lines, you can mark the opening braces with this special side comment.

           Only the opening brace needs to be marked, since perltidy knows where the closing brace is.  Braces
           contained within marked braces may also be marked as non-indenting.

           If your code happens to have some opening braces followed by '#<<<', and you don't want this behavior, you
           can use --nnnniibb to deactivate it.  To make it easy to remember, the default string is the same as the string
           for starting a ffoorrmmaatt--sskkiippppiinngg section. There is no confusion because in that case it is for a block comment
           rather than a side-comment.

           The special side comment can be changed with the next parameter.

       --nniibbpp==ss, ----nnoonn--iinnddeennttiinngg--bbrraaccee--pprreeffiixx==ss
           The --nniibbpp==ssttrriinngg parameter may be used to change the marker for non-indenting braces.  The default is
           equivalent to -nibp='#<<<'.  The string that you enter must begin with a # and should be in quotes as
           necessary to get past the command shell of your system.  This string is the leading text of a regex pattern
           that is constructed by appending pre-pending a '^' and appending a'\s', so you must also include backslashes
           for characters to be taken literally rather than as patterns.

           For example, to match the side comment '#++', the parameter would be

             -nibp='#\+\+'

       --oollqq, ----oouuttddeenntt--lloonngg--qquuootteess
           When --oollqq is set, lines which is a quoted string longer than the value mmaaxxiimmuumm--lliinnee--lleennggtthh will have their
           indentation removed to make them more readable.  This is the default.  To prevent such out-denting, use
           --nnoollqq or ----nnoooouuttddeenntt--lloonngg--lliinneess.

       --oollll, ----oouuttddeenntt--lloonngg--lliinneess
           This command is equivalent to ----oouuttddeenntt--lloonngg--qquuootteess and ----oouuttddeenntt--lloonngg--ccoommmmeennttss, and it is included for
           compatibility with previous versions of perltidy.  The negation of this also works, --nnoollll or
           ----nnoooouuttddeenntt--lloonngg--lliinneess, and is equivalent to setting --nnoollqq and --nnoollcc.

       OOuuttddeennttiinngg LLaabbeellss:: --oollaa,  ----oouuttddeenntt--llaabbeellss
           This command will cause labels to be outdented by 2 spaces (or whatever --ccii has been set to), if possible.
           This is the default.  For example:

                   my $i;
                 LOOP: while ( $i = <FOTOS> ) {
                       chomp($i);
                       next unless $i;
                       fixit($i);
                   }

           Use --nnoollaa to not outdent labels.

       OOuuttddeennttiinngg KKeeyywwoorrddss
           --ookkww,  ----oouuttddeenntt--kkeeyywwoorrddss
               The command --ookkww will cause certain leading control keywords to be outdented by 2 spaces (or whatever
               --ccii has been set to), if possible.  By default, these keywords are "redo", "next", "last", "goto", and
               "return".  The intention is to make these control keywords easier to see.  To change this list of
               keywords being outdented, see the next section.

               For example, using "perltidy -okw" on the previous example gives:

                       my $i;
                     LOOP: while ( $i = <FOTOS> ) {
                           chomp($i);
                         next unless $i;
                           fixit($i);
                       }

               The default is not to do this.

           SSppeecciiffyyiinngg OOuuttddeenntteedd KKeeyywwoorrddss:: --ookkwwll==ssttrriinngg,  ----oouuttddeenntt--kkeeyywwoorrdd--lliisstt==ssttrriinngg
               This command can be used to change the keywords which are outdented with the --ookkww command.  The
               parameter ssttrriinngg is a required list of perl keywords, which should be placed in quotes if there are more
               than one.  By itself, it does not cause any outdenting to occur, so the --ookkww command is still required.

               For example, the commands "-okwl="next last redo goto" -okw" will cause those four keywords to be
               outdented.  It is probably simplest to place any --ookkwwll command in a _._p_e_r_l_t_i_d_y_r_c file.

   WWhhiitteessppaaccee CCoonnttrrooll
       Whitespace refers to the blank space between variables, operators, and other code tokens.

       --ffwwss,  ----ffrreeeezzee--wwhhiitteessppaaccee
           This flag causes your original whitespace to remain unchanged, and causes the rest of the whitespace
           commands in this section, the Code Indentation section, and the Comment Control section to be ignored.

       TTiigghhttnneessss ooff ccuurrllyy bbrraacceess,, ppaarreenntthheesseess,, aanndd ssqquuaarree bbrraacckkeettss
           Here the term "tightness" will mean the closeness with which pairs of enclosing tokens, such as parentheses,
           contain the quantities within.  A numerical value of 0, 1, or 2 defines the tightness, with 0 being least
           tight and 2 being most tight.  Spaces within containers are always symmetric, so if there is a space after a
           "(" then there will be a space before the corresponding ")".

           The --pptt==nn or ----ppaarreenn--ttiigghhttnneessss==nn parameter controls the space within parens.  The example below shows the
           effect of the three possible values, 0, 1, and 2:

            if ( ( my $len_tab = length( $tabstr ) ) > 0 ) {  # -pt=0
            if ( ( my $len_tab = length($tabstr) ) > 0 ) {    # -pt=1 (default)
            if ((my $len_tab = length($tabstr)) > 0) {        # -pt=2

           When n is 0, there is always a space to the right of a '(' and to the left of a ')'.  For n=2 there is never
           a space.  For n=1, the default, there is a space unless the quantity within the parens is a single token,
           such as an identifier or quoted string.

           Likewise, the parameter --ssbbtt==nn or ----ssqquuaarree--bbrraacckkeett--ttiigghhttnneessss==nn controls the space within square brackets, as
           illustrated below.

            $width = $col[ $j + $k ] - $col[ $j ];  # -sbt=0
            $width = $col[ $j + $k ] - $col[$j];    # -sbt=1 (default)
            $width = $col[$j + $k] - $col[$j];      # -sbt=2

           Curly braces which do not contain code blocks are controlled by the parameter --bbtt==nn or ----bbrraaccee--ttiigghhttnneessss==nn.

            $obj->{ $parsed_sql->{ 'table' }[0] };    # -bt=0
            $obj->{ $parsed_sql->{'table'}[0] };      # -bt=1 (default)
            $obj->{$parsed_sql->{'table'}[0]};        # -bt=2

           And finally, curly braces which contain blocks of code are controlled by the parameter --bbbbtt==nn or
           ----bblloocckk--bbrraaccee--ttiigghhttnneessss==nn as illustrated in the example below.

            %bf = map { $_ => -M $_ } grep { /\.deb$/ } dirents '.'; # -bbt=0 (default)
            %bf = map { $_ => -M $_ } grep {/\.deb$/} dirents '.';   # -bbt=1
            %bf = map {$_ => -M $_} grep {/\.deb$/} dirents '.';     # -bbt=2

           To simplify input in the case that all of the tightness flags have the same value <n>, the parameter
           <-act=n> or ----aallll--ccoonnttaaiinneerrss--ttiigghhttnneessss==nn is an abbreviation for the combination <-pt=n -sbt=n -bt=n -bbt=n>.

       --ttssoo,   ----ttiigghhtt--sseeccrreett--ooppeerraattoorrss
           The flag --ttssoo causes certain perl token sequences (secret operators) which might be considered to be a
           single operator to be formatted "tightly" (without spaces).  The operators currently modified by this flag
           are:

                0+  +0  ()x!! ~~<>  ,=>   =( )=

           For example the sequence 00 ++,  which converts a string to a number, would be formatted without a space: 00++
           when the --ttssoo flag is set.  This flag is off by default.

       --ssttss,   ----ssppaaccee--tteerrmmiinnaall--sseemmiiccoolloonn
           Some programmers prefer a space before all terminal semicolons.  The default is for no such space, and is
           indicated with --nnssttss or ----nnoossppaaccee--tteerrmmiinnaall--sseemmiiccoolloonn.

                   $i = 1 ;     #  -sts
                   $i = 1;      #  -nsts   (default)

       --ssffss,   ----ssppaaccee--ffoorr--sseemmiiccoolloonn
           Semicolons within ffoorr loops may sometimes be hard to see, particularly when commas are also present.  This
           option places spaces on both sides of these special semicolons, and is the default.  Use --nnssffss or
           ----nnoossppaaccee--ffoorr--sseemmiiccoolloonn to deactivate it.

            for ( @a = @$ap, $u = shift @a ; @a ; $u = $v ) {  # -sfs (default)
            for ( @a = @$ap, $u = shift @a; @a; $u = $v ) {    # -nsfs

       --aasscc,  ----aadddd--sseemmiiccoolloonnss
           Setting --aasscc allows perltidy to add any missing optional semicolon at the end of a line which is followed by
           a closing curly brace on the next line.  This is the default, and may be deactivated with --nnaasscc or
           ----nnooaadddd--sseemmiiccoolloonnss.

       --ddssmm,  ----ddeelleettee--sseemmiiccoolloonnss
           Setting --ddssmm allows perltidy to delete extra semicolons which are simply empty statements.  This is the
           default, and may be deactivated with --nnddssmm or ----nnooddeelleettee--sseemmiiccoolloonnss.  (Such semicolons are not deleted,
           however, if they would promote a side comment to a block comment).

       --aawwss,  ----aadddd--wwhhiitteessppaaccee
           Setting this option allows perltidy to add certain whitespace to improve code readability.  This is the
           default. If you do not want any whitespace added, but are willing to have some whitespace deleted, use
           --nnaawwss.  (Use --ffwwss to leave whitespace completely unchanged).

       --ddwwss,  ----ddeelleettee--oolldd--wwhhiitteessppaaccee
           Setting this option allows perltidy to remove some old whitespace between characters, if necessary.  This is
           the default.  If you do not want any old whitespace removed, use --nnddwwss or ----nnooddeelleettee--oolldd--wwhhiitteessppaaccee.

       DDeettaaiilleedd wwhhiitteessppaaccee ccoonnttrroollss aarroouunndd ttookkeennss
           For those who want more detailed control over the whitespace around tokens, there are four parameters which
           can directly modify the default whitespace rules built into perltidy for any token.  They are:

           --wwllss==ss or ----wwaanntt--lleefftt--ssppaaccee==ss,

           --nnwwllss==ss or ----nnoowwaanntt--lleefftt--ssppaaccee==ss,

           --wwrrss==ss or ----wwaanntt--rriigghhtt--ssppaaccee==ss,

           --nnwwrrss==ss or ----nnoowwaanntt--rriigghhtt--ssppaaccee==ss.

           These parameters are each followed by a quoted string, ss, containing a list of token types.  No more than
           one of each of these parameters should be specified, because repeating a command-line parameter always
           overwrites the previous one before perltidy ever sees it.

           To illustrate how these are used, suppose it is desired that there be no space on either side of the token
           types == ++ -- // **.  The following two parameters would specify this desire:

             -nwls="= + - / *"    -nwrs="= + - / *"

           (Note that the token types are in quotes, and that they are separated by spaces).  With these modified
           whitespace rules, the following line of math:

             $root = -$b + sqrt( $b * $b - 4. * $a * $c ) / ( 2. * $a );

           becomes this:

             $root=-$b+sqrt( $b*$b-4.*$a*$c )/( 2.*$a );

           These parameters should be considered to be hints to perltidy rather than fixed rules, because perltidy must
           try to resolve conflicts that arise between them and all of the other rules that it uses.  One conflict that
           can arise is if, between two tokens, the left token wants a space and the right one doesn't.  In this case,
           the token not wanting a space takes priority.

           It is necessary to have a list of all token types in order to create this type of input.  Such a list can be
           obtained by the command ----dduummpp--ttookkeenn--ttyyppeess.  Also try the --DD flag on a short snippet of code and look at the
           .DEBUG file to see the tokenization.

           WWAARRNNIINNGG Be sure to put these tokens in quotes to avoid having them misinterpreted by your command shell.

       NNoottee11:: PPeerrllttiiddyy ddooeess aallwwaayyss ffoollllooww wwhhiitteessppaaccee ccoonnttrroollss
           The various parameters controlling whitespace within a program are requests which perltidy follows as well
           as possible, but there are a number of situations where changing whitespace could change program behavior
           and is not done.  Some of these are obvious; for example, we should not remove the space between the two
           plus symbols in '$x+ +$y' to avoid creating a '++' operator. Some are more subtle and involve the whitespace
           around bareword symbols and locations of possible filehandles.  For example, consider the problem of
           formatting the following subroutine:

              sub print_div {
                 my ($x,$y)=@_;
                 print $x/$y;
              }

           Suppose the user requests that / signs have a space to the left but not to the right. Perltidy will refuse
           to do this, but if this were done the result would be

              sub print_div {
                  my ($x,$y)=@_;
                  print $x /$y;
              }

           If formatted in this way, the program will not run (at least with recent versions of perl) because the $x is
           taken to be a filehandle and / is assumed to start a quote. In a complex program, there might happen to be a
           / which terminates the multiline quote without a syntax error, allowing the program to run, but not as
           intended.

           Related issues arise with other binary operator symbols, such as + and -, and in older versions of perl
           there could be problems with ternary operators.  So to avoid changing program behavior, perltidy has the
           simple rule that whitespace around possible filehandles is left unchanged.  Likewise, whitespace around
           barewords is left unchanged.  The reason is that if the barewords are defined in other modules, or in code
           that has not even been written yet, perltidy will not have seen their prototypes and must treat them
           cautiously.

           In perltidy this is implemented in the tokenizer by marking token following a pprriinntt keyword as a special
           type ZZ.  When formatting is being done, whitespace following this token type is generally left unchanged as
           a precaution against changing program behavior.  This is excessively conservative but simple and easy to
           implement.  Keywords which are treated similarly to pprriinntt include pprriinnttff, ssoorrtt, eexxeecc, ssyysstteemm.  Changes in
           spacing around parameters following these keywords may have to be made manually.  For example, the space, or
           lack of space, after the parameter $foo in the following line will be unchanged in formatting.

              system($foo );
              system($foo);

           To find if a token is of type ZZ you can use ppeerrllttiiddyy --DDEEBBUUGG. For the first line above the result is

              1: system($foo );
              1: kkkkkk{ZZZZb};

           which shows that ssyysstteemm is type kk (keyword) and $foo is type ZZ.

       NNoottee22:: PPeerrllttiiddyy''ss wwhhiitteessppaaccee rruulleess aarree nnoott ppeerrffeecctt
           Despite these precautions, it is still possible to introduce syntax errors with some asymmetric whitespace
           rules, particularly when call parameters are not placed in containing parens or braces.  For example, the
           following two lines will be parsed by perl without a syntax error:

             # original programming, syntax ok
             my @newkeys = map $_-$nrecs+@data, @oldkeys;

             # perltidy default, syntax ok
             my @newkeys = map $_ - $nrecs + @data, @oldkeys;

           But the following will give a syntax error:

             # perltidy -nwrs='-'
             my @newkeys = map $_ -$nrecs + @data, @oldkeys;

           For another example, the following two lines will be parsed without syntax error:

             # original programming, syntax ok
             for my $severity ( reverse $SEVERITY_LOWEST+1 .. $SEVERITY_HIGHEST ) { ...  }

             # perltidy default, syntax ok
             for my $severity ( reverse $SEVERITY_LOWEST + 1 .. $SEVERITY_HIGHEST ) { ... }

           But the following will give a syntax error:

             # perltidy -nwrs='+', syntax error:
             for my $severity ( reverse $SEVERITY_LOWEST +1 .. $SEVERITY_HIGHEST ) { ... }

           To avoid subtle parsing problems like this, it is best to avoid spacing a binary operator asymetrically with
           a space on the left but not on the right.

       SSppaaccee bbeettwweeeenn ssppeecciiffiicc kkeeyywwoorrddss aanndd ooppeenniinngg ppaarreenn
           When an opening paren follows a Perl keyword, no space is introduced after the keyword, unless it is (by
           default) one of these:

              my local our and or xor eq ne if else elsif until unless
              while for foreach return switch case given when

           These defaults can be modified with two commands:

           --ssaakk==ss  or ----ssppaaccee--aafftteerr--kkeeyywwoorrdd==ss  adds keywords.

           --nnssaakk==ss  or ----nnoossppaaccee--aafftteerr--kkeeyywwoorrdd==ss  removes keywords.

           where ss is a list of keywords (in quotes if necessary).  For example,

             my ( $a, $b, $c ) = @_;    # default
             my( $a, $b, $c ) = @_;     # -nsak="my local our"

           The abbreviation --nnssaakk==''**'' is equivalent to including all of the keywords in the above list.

           When both --nnssaakk==ss and --ssaakk==ss commands are included, the --nnssaakk==ss command is executed first.  For example, to
           have space after only the keywords (my, local, our) you could use --nnssaakk==""**"" --ssaakk==""mmyy llooccaall oouurr"".

           To put a space after all keywords, see the next item.

       SSppaaccee bbeettwweeeenn aallll kkeeyywwoorrddss aanndd ooppeenniinngg ppaarreennss
           When an opening paren follows a function or keyword, no space is introduced after the keyword except for the
           keywords noted in the previous item.  To always put a space between a function or keyword and its opening
           paren, use the command:

           --sskkpp  or ----ssppaaccee--kkeeyywwoorrdd--ppaarreenn

           You may also want to use the flag --ssffpp (next item) too.

       SSppaaccee bbeettwweeeenn aallll ffuunnccttiioonn nnaammeess aanndd ooppeenniinngg ppaarreennss
           When an opening paren follows a function the default and recommended formatting is not to introduce a space.
           To cause a space to be introduced use:

           --ssffpp  or ----ssppaaccee--ffuunnccttiioonn--ppaarreenn

             myfunc( $a, $b, $c );    # default
             myfunc ( $a, $b, $c );   # -sfp

           You will probably also want to use the flag --sskkpp (previous item) too.

           The reason this is not recommended is that spacing a function paren can make a program vulnerable to parsing
           problems by Perl.  For example, the following two-line program will run as written but will have a syntax
           error if reformatted with -sfp:

             if ( -e filename() ) { print "I'm here\n"; }
             sub filename { return $0 }

           In this particular case the syntax error can be removed if the line order is reversed, so that Perl parses
           'sub filename' first.

       --ffppvvaa  or ----ffuunnccttiioonn--ppaarreenn--vveerrttiiccaall--aalliiggnnmmeenntt
           A side-effect of using the --ssffpp flag is that the parens may become vertically aligned. For example,

               # perltidy -sfp
               myfun     ( $aaa, $b, $cc );
               mylongfun ( $a, $b, $c );

           This is the default behavior.  To prevent this alignment use --nnffppvvaa:

               # perltidy -sfp -nfpva
               myfun ( $aaa, $b, $cc );
               mylongfun ( $a, $b, $c );

       --sspppp==nn  or ----ssppaaccee--pprroottoottyyppee--ppaarreenn==nn
           This flag can be used to control whether a function prototype is preceded by a space.  For example, the
           following prototype does not have a space.

                 sub usage();

           This integer nn may have the value 0, 1, or 2 as follows:

               -spp=0 means no space before the paren
               -spp=1 means follow the example of the source code [DEFAULT]
               -spp=2 means always put a space before the paren

           The default is --sspppp==11, meaning that a space will be used if and only if there is one in the source code.
           Given the above line of code, the result of applying the different options would be:

                   sub usage();    # n=0 [no space]
                   sub usage();    # n=1 [default; follows input]
                   sub usage ();   # n=2 [space]

       --kkppiitt==nn or ----kkeeyywwoorrdd--ppaarreenn--iinnnneerr--ttiigghhttnneessss==nn
           The space inside of an opening paren, which itself follows a certain keyword, can be controlled by this
           parameter.  The space on the inside of the corresponding closing paren will be treated in the same
           (balanced) manner.  This parameter has precedence over any other paren spacing rules.  The values of nn are
           as follows:

              -kpit=0 means always put a space (not tight)
              -kpit=1 means ignore this parameter [default]
              -kpit=2 means never put a space (tight)

           To illustrate, the following snippet is shown formatted in three ways:

               if ( seek( DATA, 0, 0 ) ) { ... }    # perltidy (default)
               if (seek(DATA, 0, 0)) { ... }        # perltidy -pt=2
               if ( seek(DATA, 0, 0) ) { ... }      # perltidy -pt=2 -kpit=0

           In the second case the -pt=2 parameter makes all of the parens tight. In the third case the -kpit=0 flag
           causes the space within the 'if' parens to have a space, since 'if' is one of the keywords to which the
           -kpit flag applies by default.  The remaining parens are still tight because of the -pt=2 parameter.

           The set of keywords to which this parameter applies are by default are:

              if elsif unless while until for foreach

           These can be changed with the parameter --kkppiittll==ss described in the next section.

       --kkppiittll==ssttrriinngg or ----kkeeyywwoorrdd--ppaarreenn--iinnnneerr--ttiigghhttnneessss==ssttrriinngg
           This command can be used to change the keywords to which the the --kkppiitt==nn command applies.  The parameter
           ssttrriinngg is a required list either keywords or functions, which should be placed in quotes if there are more
           than one.  By itself, this parameter does not cause any change in spacing, so the --kkppiitt==nn command is still
           required.

           For example, the commands "-kpitl="if else while" -kpit=2" will cause the just the spaces inside parens
           following  'if', 'else', and 'while' keywords to follow the tightness value indicated by the --kkppiitt==22 flag.

       --lloopp  or ----llooggiiccaall--ppaaddddiinngg
           In the following example some extra space has been inserted on the second line between the two open parens.
           This extra space is called "logical padding" and is intended to help align similar things vertically in some
           logical or ternary expressions.

               # perltidy [default formatting]
               $same =
                 (      ( $aP eq $bP )
                     && ( $aS eq $bS )
                     && ( $aT eq $bT )
                     && ( $a->{'title'} eq $b->{'title'} )
                     && ( $a->{'href'} eq $b->{'href'} ) );

           Note that this is considered to be a different operation from "vertical alignment" because space at just one
           line is being adjusted, whereas in "vertical alignment" the spaces at all lines are being adjusted. So it
           sort of a local version of vertical alignment.

           Here is an example involving a ternary operator:

               # perltidy [default formatting]
               $bits =
                   $top > 0xffff ? 32
                 : $top > 0xff   ? 16
                 : $top > 1      ? 8
                 :                 1;

           This behavior is controlled with the flag ----llooggiiccaall--ppaaddddiinngg, which is set 'on' by default.  If it is not
           desired it can be turned off using ----nnoollooggiiccaall--ppaaddddiinngg or --nnlloopp.  The above two examples become, with --nnlloopp:

               # perltidy -nlop
               $same =
                 ( ( $aP eq $bP )
                     && ( $aS eq $bS )
                     && ( $aT eq $bT )
                     && ( $a->{'title'} eq $b->{'title'} )
                     && ( $a->{'href'} eq $b->{'href'} ) );

               # perltidy -nlop
               $bits =
                 $top > 0xffff ? 32
                 : $top > 0xff ? 16
                 : $top > 1    ? 8
                 :               1;

       TTrriimmmmiinngg wwhhiitteessppaaccee aarroouunndd ""qqww"" qquuootteess
           --ttqqww or ----ttrriimm--qqww provide the default behavior of trimming spaces around multi-line "qw" quotes and
           indenting them appropriately.

           --nnttqqww or ----nnoottrriimm--qqww cause leading and trailing whitespace around multi-line "qw" quotes to be left
           unchanged.  This option will not normally be necessary, but was added for testing purposes, because in some
           versions of perl, trimming "qw" quotes changes the syntax tree.

       --ssbbqq==nn  or ----ssppaaccee--bbaacckkssllaasshh--qquuoottee==nn
           lines like

                  $str1=\"string1";
                  $str2=\'string2';

           can confuse syntax highlighters unless a space is included between the backslash and the single or double
           quotation mark.

           this can be controlled with the value of nn as follows:

               -sbq=0 means no space between the backslash and quote
               -sbq=1 means follow the example of the source code
               -sbq=2 means always put a space between the backslash and quote

           The default is --ssbbqq==11, meaning that a space will be used if there is one in the source code.

       TTrriimmmmiinngg ttrraaiilliinngg wwhhiitteessppaaccee ffrroomm lliinneess ooff PPOODD
           --ttrrpp or ----ttrriimm--ppoodd will remove trailing whitespace from lines of POD.  The default is not to do this.

   CCoommmmeenntt CCoonnttrroollss
       Perltidy has a number of ways to control the appearance of both block comments and side comments.  The term
       bblloocckk ccoommmmeenntt here refers to a full-line comment, whereas ssiiddee ccoommmmeenntt will refer to a comment which appears on
       a line to the right of some code.

       --iibbcc,  ----iinnddeenntt--bblloocckk--ccoommmmeennttss
           Block comments normally look best when they are indented to the same level as the code which follows them.
           This is the default behavior, but you may use --nniibbcc to keep block comments left-justified.  Here is an
           example:

                        # this comment is indented      (-ibc, default)
                        if ($task) { yyy(); }

           The alternative is --nniibbcc:

            # this comment is not indented              (-nibc)
                        if ($task) { yyy(); }

           See also the next item, --iissbbcc, as well as --ssbbcc, for other ways to have some indented and some outdented
           block comments.

       --iissbbcc,  ----iinnddeenntt--ssppaacceedd--bblloocckk--ccoommmmeennttss
           If there is no leading space on the line, then the comment will not be indented, and otherwise it may be.

           If both --iibbcc and --iissbbcc are set, then --iissbbcc takes priority.

       --oollcc, ----oouuttddeenntt--lloonngg--ccoommmmeennttss
           When --oollcc is set, lines which are full-line (block) comments longer than the value mmaaxxiimmuumm--lliinnee--lleennggtthh will
           have their indentation removed.  This is the default; use --nnoollcc to prevent outdenting.

       --mmsscc==nn,  ----mmiinniimmuumm--ssppaaccee--ttoo--ccoommmmeenntt==nn
           Side comments look best when lined up several spaces to the right of code.  Perltidy will try to keep
           comments at least n spaces to the right.  The default is n=4 spaces.

       --ffppsscc==nn,  ----ffiixxeedd--ppoossiittiioonn--ssiiddee--ccoommmmeenntt==nn
           This parameter tells perltidy to line up side comments in column number nn whenever possible.  The default,
           n=0, will not do this.

       --iissccll,  ----iiggnnoorree--ssiiddee--ccoommmmeenntt--lleennggtthhss
           This parameter causes perltidy to ignore the length of side comments when setting line breaks.  The default,
           --nniissccll, is to include the length of side comments when breaking lines to stay within the length prescribed
           by the --ll==nn maximum line length parameter.  For example, the following long single line would remain intact
           with -l=80 and -iscl:

                perltidy -l=80 -iscl
                   $vmsfile =~ s/;[\d\-]*$//; # Clip off version number; we can use a newer version as well

           whereas without the -iscl flag the line will be broken:

                perltidy -l=80
                   $vmsfile =~ s/;[\d\-]*$//
                     ;    # Clip off version number; we can use a newer version as well

       --hhsscc, ----hhaannggiinngg--ssiiddee--ccoommmmeennttss
           By default, perltidy tries to identify and align "hanging side comments", which are something like this:

                   my $IGNORE = 0;    # This is a side comment
                                      # This is a hanging side comment
                                      # And so is this

           A comment is considered to be a hanging side comment if (1) it immediately follows a line with a side
           comment, or another hanging side comment, and (2) there is some leading whitespace on the line.  To
           deactivate this feature, use --nnhhsscc or ----nnoohhaannggiinngg--ssiiddee--ccoommmmeennttss.  If block comments are preceded by a blank
           line, or have no leading whitespace, they will not be mistaken as hanging side comments.

       CClloossiinngg SSiiddee CCoommmmeennttss
           A closing side comment is a special comment which perltidy can automatically create and place after the
           closing brace of a code block.  They can be useful for code maintenance and debugging.  The command --ccsscc (or
           ----cclloossiinngg--ssiiddee--ccoommmmeennttss) adds or updates closing side comments.  For example, here is a small code snippet

                   sub message {
                       if ( !defined( $_[0] ) ) {
                           print("Hello, World\n");
                       }
                       else {
                           print( $_[0], "\n" );
                       }
                   }

           And here is the result of processing with "perltidy -csc":

                   sub message {
                       if ( !defined( $_[0] ) ) {
                           print("Hello, World\n");
                       }
                       else {
                           print( $_[0], "\n" );
                       }
                   } ## end sub message

           A closing side comment was added for "sub message" in this case, but not for the "if" and "else" blocks,
           because they were below the 6 line cutoff limit for adding closing side comments.  This limit may be changed
           with the --ccssccii command, described below.

           The command --ddccsscc (or ----ddeelleettee--cclloossiinngg--ssiiddee--ccoommmmeennttss) reverses this process and removes these comments.

           Several commands are available to modify the behavior of these two basic commands, --ccsscc and --ddccsscc:

           --ccssccii==nn, or ----cclloossiinngg--ssiiddee--ccoommmmeenntt--iinntteerrvvaall==nn
               where "n" is the minimum number of lines that a block must have in order for a closing side comment to
               be added.  The default value is "n=6".  To illustrate:

                       # perltidy -csci=2 -csc
                       sub message {
                           if ( !defined( $_[0] ) ) {
                               print("Hello, World\n");
                           } ## end if ( !defined( $_[0] ))
                           else {
                               print( $_[0], "\n" );
                           } ## end else [ if ( !defined( $_[0] ))
                       } ## end sub message

               Now the "if" and "else" blocks are commented.  However, now this has become very cluttered.

           --ccssccpp==ssttrriinngg, or ----cclloossiinngg--ssiiddee--ccoommmmeenntt--pprreeffiixx==ssttrriinngg
               where string is the prefix used before the name of the block type.  The default prefix, shown above, is
               "## end".  This string will be added to closing side comments, and it will also be used to recognize
               them in order to update, delete, and format them.  Any comment identified as a closing side comment will
               be placed just a single space to the right of its closing brace.

           --ccssccll==ssttrriinngg, or ----cclloossiinngg--ssiiddee--ccoommmmeenntt--lliisstt
               where "string" is a list of block types to be tagged with closing side comments.  By default, all code
               block types preceded by a keyword or label (such as "if", "sub", and so on) will be tagged.  The --ccssccll
               command changes the default list to be any selected block types; see "Specifying Block Types".  For
               example, the following command requests that only "sub"'s, labels, "BEGIN", and "END" blocks be affected
               by any --ccsscc or --ddccsscc operation:

                  -cscl="sub : BEGIN END"

           --ccsscctt==nn, or ----cclloossiinngg--ssiiddee--ccoommmmeenntt--mmaaxxiimmuumm--tteexxtt==nn
               The text appended to certain block types, such as an "if" block, is whatever lies between the keyword
               introducing the block, such as "if", and the opening brace.  Since this might be too much text for a
               side comment, there needs to be a limit, and that is the purpose of this parameter.  The default value
               is "n=20", meaning that no additional tokens will be appended to this text after its length reaches 20
               characters.  Omitted text is indicated with "...".  (Tokens, including sub names, are never truncated,
               however, so actual lengths may exceed this).  To illustrate, in the above example, the appended text of
               the first block is " ( !defined( $_[0] )...".  The existing limit of "n=20" caused this text to be
               truncated, as indicated by the "...".  See the next flag for additional control of the abbreviated text.

           --ccssccbb, or ----cclloossiinngg--ssiiddee--ccoommmmeennttss--bbaallaanncceedd
               As discussed in the previous item, when the closing-side-comment-maximum-text limit is exceeded the
               comment text must be truncated.  Older versions of perltidy terminated with three dots, and this can
               still be achieved with -ncscb:

                 perltidy -csc -ncscb
                 } ## end foreach my $foo (sort { $b cmp $a ...

               However this causes a problem with editors which cannot recognize comments or are not configured to do
               so because they cannot "bounce" around in the text correctly.  The --ccssccbb flag has been added to help
               them by appending appropriate balancing structure:

                 perltidy -csc -cscb
                 } ## end foreach my $foo (sort { $b cmp $a ... })

               The default is --ccssccbb.

           --ccssccee==nn, or ----cclloossiinngg--ssiiddee--ccoommmmeenntt--eellssee--ffllaagg==nn
               The default, nn==00, places the text of the opening "if" statement after any terminal "else".

               If nn==22 is used, then each "elsif" is also given the text of the opening "if" statement.  Also, an "else"
               will include the text of a preceding "elsif" statement.  Note that this may result some long closing
               side comments.

               If nn==11 is used, the results will be the same as nn==22 whenever the resulting line length is less than the
               maximum allowed.

           --ccssccbb, or ----cclloossiinngg--ssiiddee--ccoommmmeennttss--bbaallaanncceedd
               When using closing-side-comments, and the closing-side-comment-maximum-text limit is exceeded, then the
               comment text must be abbreviated.  It is terminated with three dots if the --ccssccbb flag is negated:

                 perltidy -csc -ncscb
                 } ## end foreach my $foo (sort { $b cmp $a ...

               This causes a problem with older editors which do not recognize comments because they cannot "bounce"
               around in the text correctly.  The --ccssccbb flag tries to help them by appending appropriate terminal
               balancing structures:

                 perltidy -csc -cscb
                 } ## end foreach my $foo (sort { $b cmp $a ... })

               The default is --ccssccbb.

           --ccssccww, or ----cclloossiinngg--ssiiddee--ccoommmmeenntt--wwaarrnniinnggss
               This parameter is intended to help make the initial transition to the use of closing side comments.  It
               causes two things to happen if a closing side comment replaces an existing, different closing side
               comment:  first, an error message will be issued, and second, the original side comment will be placed
               alone on a new specially marked comment line for later attention.

               The intent is to avoid clobbering existing hand-written side comments which happen to match the pattern
               of closing side comments. This flag should only be needed on the first run with --ccsscc.

           IImmppoorrttaanntt NNootteess oonn CClloossiinngg SSiiddee CCoommmmeennttss::

           +o   Closing side comments are only placed on lines terminated with a closing brace.  Certain closing styles,
               such as the use of cuddled elses (--ccee), preclude the generation of some closing side comments.

           +o   Please note that adding or deleting of closing side comments takes place only through the commands --ccsscc
               or --ddccsscc.  The other commands, if used, merely modify the behavior of these two commands.

           +o   It is recommended that the --ccssccww flag be used along with --ccsscc on the first use of perltidy on a given
               file.  This will prevent loss of any existing side comment data which happens to have the csc prefix.

           +o   Once you use --ccsscc, you should continue to use it so that any closing side comments remain correct as
               code changes.  Otherwise, these comments will become incorrect as the code is updated.

           +o   If you edit the closing side comments generated by perltidy, you must also change the prefix to be
               different from the closing side comment prefix.  Otherwise, your edits will be lost when you rerun
               perltidy with --ccsscc.   For example, you could simply change "## end" to be "## End", since the test is
               case sensitive.  You may also want to use the --sssscc flag to keep these modified closing side comments
               spaced the same as actual closing side comments.

           +o   Temporarily generating closing side comments is a useful technique for exploring and/or debugging a perl
               script, especially one written by someone else.  You can always remove them with --ddccsscc.

       SSttaattiicc BBlloocckk CCoommmmeennttss
           Static block comments are block comments with a special leading pattern, "##" by default, which will be
           treated slightly differently from other block comments.  They effectively behave as if they had glue along
           their left and top edges, because they stick to the left edge and previous line when there is no blank
           spaces in those places.  This option is particularly useful for controlling how commented code is displayed.

           --ssbbcc, ----ssttaattiicc--bblloocckk--ccoommmmeennttss
               When --ssbbcc is used, a block comment with a special leading pattern, "##" by default, will be treated
               specially.

               Comments so identified  are treated as follows:

               +o   If there is no leading space on the line, then the comment will not be indented, and otherwise it
                   may be,

               +o   no new blank line will be inserted before such a comment, and

               +o   such a comment will never become a hanging side comment.

               For example, assuming @month_of_year is left-adjusted:

                   @month_of_year = (    # -sbc (default)
                       'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct',
                   ##  'Dec', 'Nov'
                       'Nov', 'Dec');

               Without this convention, the above code would become

                   @month_of_year = (   # -nsbc
                       'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct',

                       ##  'Dec', 'Nov'
                       'Nov', 'Dec'
                   );

               which is not as clear.  The default is to use --ssbbcc.  This may be deactivated with --nnssbbcc.

           --ssbbccpp==ssttrriinngg, ----ssttaattiicc--bblloocckk--ccoommmmeenntt--pprreeffiixx==ssttrriinngg
               This parameter defines the prefix used to identify static block comments when the --ssbbcc parameter is set.
               The default prefix is "##", corresponding to "-sbcp=##".  The prefix is actually part of a perl pattern
               used to match lines and it must either begin with "#" or "^#".  In the first case a prefix ^\s* will be
               added to match any leading whitespace, while in the second case the pattern will match only comments
               with no leading whitespace.  For example, to identify all comments as static block comments, one would
               use "-sbcp=#".  To identify all left-adjusted comments as static block comments, use "-sbcp='^#'".

               Please note that --ssbbccpp merely defines the pattern used to identify static block comments; it will not be
               used unless the switch --ssbbcc is set.  Also, please be aware that since this string is used in a perl
               regular expression which identifies these comments, it must enable a valid regular expression to be
               formed.

               A pattern which can be useful is:

                   -sbcp=^#{2,}[^\s#]

               This pattern requires a static block comment to have at least one character which is neither a # nor a
               space.  It allows a line containing only '#' characters to be rejected as a static block comment.  Such
               lines are often used at the start and end of header information in subroutines and should not be
               separated from the intervening comments, which typically begin with just a single '#'.

           --oossbbcc, ----oouuttddeenntt--ssttaattiicc--bblloocckk--ccoommmmeennttss
               The command --oossbbcc will cause static block comments to be outdented by 2 spaces (or whatever --ccii==nn has
               been set to), if possible.

       SSttaattiicc SSiiddee CCoommmmeennttss
           Static side comments are side comments with a special leading pattern.  This option can be useful for
           controlling how commented code is displayed when it is a side comment.

           --sssscc, ----ssttaattiicc--ssiiddee--ccoommmmeennttss
               When --sssscc is used, a side comment with a static leading pattern, which is "##" by default, will be
               spaced only a single space from previous character, and it will not be vertically aligned with other
               side comments.

               The default is --nnsssscc.

           --ssssccpp==ssttrriinngg, ----ssttaattiicc--ssiiddee--ccoommmmeenntt--pprreeffiixx==ssttrriinngg
               This parameter defines the prefix used to identify static side comments when the --sssscc parameter is set.
               The default prefix is "##", corresponding to "-sscp=##".

               Please note that --ssssccpp merely defines the pattern used to identify static side comments; it will not be
               used unless the switch --sssscc is set.  Also, note that this string is used in a perl regular expression
               which identifies these comments, so it must enable a valid regular expression to be formed.

   SSkkiippppiinngg SSeelleecctteedd SSeeccttiioonnss ooff CCooddee
       Selected lines of code may be passed verbatim to the output without any formatting by marking the starting and
       ending lines with special comments.  There are two options for doing this.  The first option is called
       ----ffoorrmmaatt--sskkiippppiinngg or --ffss, and the second option is called ----ccooddee--sskkiippppiinngg or --ccss.

       In both cases the lines of code will be output without any changes.  The difference is that in ----ffoorrmmaatt--sskkiippppiinngg
       perltidy will still parse the marked lines of code and check for errors, whereas in ----ccooddee--sskkiippppiinngg perltidy
       will simply pass the lines to the output without any checking.

       Both of these features are enabled by default and are invoked with special comment markers.  ----ffoorrmmaatt--sskkiippppiinngg
       uses starting and ending markers '#<<<' and '#>>>', like this:

        #<<<  format skipping: do not let perltidy change my nice formatting
           my @list = (1,
                       1, 1,
                       1, 2, 1,
                       1, 3, 3, 1,
                       1, 4, 6, 4, 1,);
        #>>>

       ----ccooddee--sskkiippppiinngg uses starting and ending markers '#<<V' and '#>>V', like this:

        #<<V  code skipping: perltidy will pass this verbatim without error checking

           token ident_digit {
               [ [ <?word> | _ | <?digit> ] <?ident_digit>
               |   <''>
               ]
           };

        #>>V

       Additional text may appear on the special comment lines provided that it is separated from the marker by at
       least one space, as in the above examples.

       It is recommended to use ----ccooddee--sskkiippppiinngg only if you need to hide a block of an extended syntax which would
       produce errors if parsed by perltidy, and use ----ffoorrmmaatt--sskkiippppiinngg otherwise.  This is because the
       ----ffoorrmmaatt--sskkiippppiinngg option provides the benefits of error checking, and there are essentially no limitations on
       which lines to which it can be applied.  The ----ccooddee--sskkiippppiinngg option, on the other hand, does not do error
       checking and its use is more restrictive because the code which remains, after skipping the marked lines, must
       be syntactically correct code with balanced containers.

       These features should be used sparingly to avoid littering code with markers, but they can be helpful for
       working around occasional problems.

       Note that it may be possible to avoid the use of ----ffoorrmmaatt--sskkiippppiinngg for the specific case of a comma-separated
       list of values, as in the above example, by simply inserting a blank or comment somewhere between the opening
       and closing parens.  See the section "Controlling List Formatting".

       The following sections describe the available controls for these options.  They should not normally be needed.

       --ffss,  ----ffoorrmmaatt--sskkiippppiinngg
           As explained above, this flag, which is enabled by default, causes any code between special beginning and
           ending comment markers to be passed to the output without formatting.  The code between the comments is
           still checked for errors however.  The default beginning marker is #<<< and the default ending marker is
           #>>>.

           Format skipping begins when a format skipping beginning comment is seen and continues until a format-
           skipping ending comment is found.

           This feature can be disabled with --nnffss.   This should not normally be necessary.

       --ffssbb==ssttrriinngg,  ----ffoorrmmaatt--sskkiippppiinngg--bbeeggiinn==ssttrriinngg
           This and the next parameter allow the special beginning and ending comments to be changed.  However, it is
           recommended that they only be changed if there is a conflict between the default values and some other use.
           If they are used, it is recommended that they only be entered in a ..ppeerrllttiiddyyrrcc file, rather than on a
           command line.  This is because properly escaping these parameters on a command line can be difficult.

           If changed comment markers do not appear to be working, use the --lloogg flag and examine the _._L_O_G file to see
           if and where they are being detected.

           The --ffssbb==ssttrriinngg parameter may be used to change the beginning marker for format skipping.  The default is
           equivalent to -fsb='#<<<'.  The string that you enter must begin with a # and should be in quotes as
           necessary to get past the command shell of your system.  It is actually the leading text of a pattern that
           is constructed by appending a '\s', so you must also include backslashes for characters to be taken
           literally rather than as patterns.

           Some examples show how example strings become patterns:

            -fsb='#\{\{\{' becomes /^#\{\{\{\s/  which matches  #{{{ but not #{{{{
            -fsb='#\*\*'   becomes /^#\*\*\s/    which matches  #** but not #***
            -fsb='#\*{2,}' becomes /^#\*{2,}\s/  which matches  #** and #*****

       --ffssee==ssttrriinngg,  ----ffoorrmmaatt--sskkiippppiinngg--eenndd==ssttrriinngg
           The --ffssee==ssttrriinngg is the corresponding parameter used to change the ending marker for format skipping.  The
           default is equivalent to -fse='#<<<'.

           The beginning and ending strings may be the same, but it is preferable to make them different for clarity.

       --ccss,  ----ccooddee--sskkiippppiinngg
           As explained above, this flag, which is enabled by default, causes any code between special beginning and
           ending comment markers to be directly passed to the output without any error checking or formatting.
           Essentially, perltidy treats it as if it were a block of arbitrary text.  The default beginning marker is
           #<<V and the default ending marker is #>>V.

           This feature can be disabled with --nnccss.   This should not normally be necessary.

       --ccssbb==ssttrriinngg,  ----ccooddee--sskkiippppiinngg--bbeeggiinn==ssttrriinngg
           This may be used to change the beginning comment for a ----ccooddee--sskkiippppiinngg section, and its use is similar to
           the --ffssbb==ssttrriinngg.  The default is equivalent to -csb='#<<V'.

       --ccssee==ssttrriinngg,  ----ccooddee--sskkiippppiinngg--eenndd==ssttrriinngg
           This may be used to change the ending comment for a ----ccooddee--sskkiippppiinngg section, and its use is similar to the
           --ffssee==ssttrriinngg.  The default is equivalent to -cse='#>>V'.

   LLiinnee BBrreeaakk CCoonnttrrooll
       The parameters in this section control breaks after non-blank lines of code.  Blank lines are controlled
       separately by parameters in the section "Blank Line Control".

       --ffnnll,  ----ffrreeeezzee--nneewwlliinneess
           If you do not want any changes to the line breaks within lines of code in your script, set --ffnnll, and they
           will remain fixed, and the rest of the commands in this section and sections "Controlling List Formatting",
           "Retaining or Ignoring Existing Line Breaks".  You may want to use --nnoollll with this.

           Note: If you also want to keep your blank lines exactly as they are, you can use the --ffbbll flag which is
           described in the section "Blank Line Control".

       --ccee,   ----ccuuddddlleedd--eellssee
           Enable the "cuddled else" style, in which "else" and "elsif" are follow immediately after the curly brace
           closing the previous block.  The default is not to use cuddled elses, and is indicated with the flag --nnccee or
           ----nnooccuuddddlleedd--eellssee.  Here is a comparison of the alternatives:

             # -ce
             if ($task) {
                 yyy();
             } else {
                 zzz();
             }

             # -nce (default)
             if ($task) {
                   yyy();
             }
             else {
                   zzz();
             }

           In this example the keyword eellssee is placed on the same line which begins with the preceding closing block
           brace and is followed by its own opening block brace on the same line.  Other keywords and function names
           which are formatted with this "cuddled" style are eellssiiff, ccoonnttiinnuuee, ccaattcchh, ffiinnaallllyy.

           Other block types can be formatted by specifying their names on a separate parameter --ccbbll, described in a
           later section.

           Cuddling between a pair of code blocks requires that the closing brace of the first block start a new line.
           If this block is entirely on one line in the input file, it is necessary to decide if it should be broken to
           allow cuddling.  This decision is controlled by the flag --ccbboo==nn discussed below.  The default and
           recommended value of --ccbboo==11 bases this decision on the first block in the chain.  If it spans multiple lines
           then cuddling is made and continues along the chain, regardless of the sizes of subsequent blocks.
           Otherwise, short lines remain intact.

           So for example, the --ccee flag would not have any effect if the above snippet is rewritten as

             if ($task) { yyy() }
             else {    zzz() }

           If the first block spans multiple lines, then cuddling can be done and will continue for the subsequent
           blocks in the chain, as illustrated in the previous snippet.

           If there are blank lines between cuddled blocks they will be eliminated.  If there are comments after the
           closing brace where cuddling would occur then cuddling will be prevented.  If this occurs, cuddling will
           restart later in the chain if possible.

       --ccbb,   ----ccuuddddlleedd--bblloocckkss
           This flag is equivalent to --ccee.

       --ccbbll,    ----ccuuddddlleedd--bblloocckk--lliisstt
           The built-in default cuddled block types are eellssee,, eellssiiff,, ccoonnttiinnuuee,, ccaattcchh,, ffiinnaallllyy.

           Additional block types to which the --ccuuddddlleedd--bblloocckkss style applies can be defined by this parameter.  This
           parameter is a character string, giving a list of block types separated by commas or spaces.  For example,
           to cuddle code blocks of type sort, map and grep, in addition to the default types, the string could be set
           to

             -cbl="sort map grep"

           or equivalently

             -cbl=sort,map,grep

           Note however that these particular block types are typically short so there might not be much opportunity
           for the cuddled format style.

           Using commas avoids the need to protect spaces with quotes.

           As a diagnostic check, the flag ----dduummpp--ccuuddddlleedd--bblloocckk--lliisstt or --ddccbbll can be used to view the hash of values
           that are generated by this flag.

           Finally, note that the --ccbbll flag by itself merely specifies which blocks are formatted with the cuddled
           format. It has no effect unless this formatting style is activated with --ccee.

       --ccbbllxx,    ----ccuuddddlleedd--bblloocckk--lliisstt--eexxcclluussiivvee
           When cuddled else formatting is selected with --ccee, setting this flag causes perltidy to ignore its built-in
           defaults and rely exclusively on the block types specified on the --ccbbll flag described in the previous
           section.  For example, to avoid using cuddled ccaattcchh and ffiinnaallllyy, which among in the defaults, the following
           set of parameters could be used:

             perltidy -ce -cbl='else elsif continue' -cblx

       --ccbboo==nn,   ----ccuuddddlleedd--bbrreeaakk--ooppttiioonn==nn
           Cuddled formatting is only possible between a pair of code blocks if the closing brace of the first block
           starts a new line. If a block is encountered which is entirely on a single line, and cuddled formatting is
           selected, it is necessary to make a decision as to whether or not to "break" the block, meaning to cause it
           to span multiple lines.  This parameter controls that decision. The options are:

              cbo=0  Never force a short block to break.
              cbo=1  If the first of a pair of blocks is broken in the input file,
                     then break the second [DEFAULT].
              cbo=2  Break open all blocks for maximal cuddled formatting.

           The default and recommended value is ccbboo==11.  With this value, if the starting block of a chain spans
           multiple lines, then a cascade of breaks will occur for remaining blocks causing the entire chain to be
           cuddled.

           The option ccbboo==00 can produce erratic cuddling if there are numerous one-line blocks.

           The option ccbboo==22 produces maximal cuddling but will not allow any short blocks.

       --bbll,    ----ooppeenniinngg--bbrraaccee--oonn--nneeww--lliinnee
           Use the flag --bbll to place the opening brace on a new line:

             if ( $input_file eq '-' )    # -bl
             {
                 important_function();
             }

           This flag applies to all structural blocks, including named sub's (unless the --ssbbll flag is set -- see next
           item).

           The default style, --nnbbll, places an opening brace on the same line as the keyword introducing it.  For
           example,

             if ( $input_file eq '-' ) {   # -nbl (default)

       --ssbbll,    ----ooppeenniinngg--ssuubb--bbrraaccee--oonn--nneeww--lliinnee
           The flag --ssbbll can be used to override the value of --bbll for the opening braces of named sub's.  For example,

            perltidy -sbl

           produces this result:

            sub message
            {
               if (!defined($_[0])) {
                   print("Hello, World\n");
               }
               else {
                   print($_[0], "\n");
               }
            }

           This flag is negated with --nnssbbll.  If --ssbbll is not specified, the value of --bbll is used.

       --aassbbll,    ----ooppeenniinngg--aannoonnyymmoouuss--ssuubb--bbrraaccee--oonn--nneeww--lliinnee
           The flag --aassbbll is like the --ssbbll flag except that it applies to anonymous sub's instead of named subs. For
           example

            perltidy -asbl

           produces this result:

            $a = sub
            {
                if ( !defined( $_[0] ) ) {
                    print("Hello, World\n");
                }
                else {
                    print( $_[0], "\n" );
                }
            };

           This flag is negated with --nnaassbbll, and the default is --nnaassbbll.

       --bbllii,    ----bbrraaccee--lleefftt--aanndd--iinnddeenntt
           The flag --bbllii is the same as --bbll but in addition it causes one unit of continuation indentation ( see --ccii )
           to be placed before an opening and closing block braces.

           For example,

                   if ( $input_file eq '-' )    # -bli
                     {
                       important_function();
                     }

           By default, this extra indentation occurs for blocks of type: iiff, eellssiiff, eellssee, uunnlleessss, ffoorr, ffoorreeaacchh, ssuubb,
           wwhhiillee, uunnttiill, and also with a preceding label.  The next item shows how to change this.

       --bblliill==ss,    ----bbrraaccee--lleefftt--aanndd--iinnddeenntt--lliisstt==ss
           Use this parameter to change the types of block braces for which the --bbllii flag applies; see "Specifying
           Block Types".  For example, --bblliill==''iiff eellssiiff eellssee'' would apply it to only "if/elsif/else" blocks.

       --bbaarr,    ----ooppeenniinngg--bbrraaccee--aallwwaayyss--oonn--rriigghhtt
           The default style, --nnbbll places the opening code block brace on a new line if it does not fit on the same
           line as the opening keyword, like this:

                   if ( $bigwasteofspace1 && $bigwasteofspace2
                     || $bigwasteofspace3 && $bigwasteofspace4 )
                   {
                       big_waste_of_time();
                   }

           To force the opening brace to always be on the right, use the --bbaarr flag.  In this case, the above example
           becomes

                   if ( $bigwasteofspace1 && $bigwasteofspace2
                     || $bigwasteofspace3 && $bigwasteofspace4 ) {
                       big_waste_of_time();
                   }

           A conflict occurs if both --bbll and --bbaarr are specified.

       --oottrr,  ----ooppeenniinngg--ttookkeenn--rriigghhtt and related flags
           The --oottrr flag is a hint that perltidy should not place a break between a comma and an opening token.  For
           example:

               # default formatting
               push @{ $self->{$module}{$key} },
                 {
                   accno       => $ref->{accno},
                   description => $ref->{description}
                 };

               # perltidy -otr
               push @{ $self->{$module}{$key} }, {
                   accno       => $ref->{accno},
                   description => $ref->{description}
                 };

           The flag --oottrr is actually an abbreviation for three other flags which can be used to control parens, hash
           braces, and square brackets separately if desired:

             -opr  or --opening-paren-right
             -ohbr or --opening-hash-brace-right
             -osbr or --opening-square-bracket-right

       --bbbbhhbb==nn,  ----bbrreeaakk--bbeeffoorree--hhaasshh--bbrraaccee==nn and related flags
           When a list of items spans multiple lines, the default formatting is to place the opening brace (or other
           container token) at the end of the starting line, like this:

               $romanNumerals = {
                   one   => 'I',
                   two   => 'II',
                   three => 'III',
                   four  => 'IV',
               };

           This flag can change the default behavior to cause a line break to be placed before the opening brace
           according to the value given to the integer nn:

             -bbhb=0 never break [default]
             -bbhb=1 stable: break if the input script had a break
             -bbhb=2 break if list is 'complex' (see note below)
             -bbhb=3 always break

           For example,

               # perltidy -bbhb=3
               $romanNumerals =
                 {
                   one   => 'I',
                   two   => 'II',
                   three => 'III',
                   four  => 'IV',
                 };

           There are several points to note about this flag:

           +o   This parameter only applies if the opening brace is preceded by an '=' or '=>'.

           +o   This parameter only applies if the contents of the container looks like a list.  The contents need to
               contain some commas or '=>'s at the next interior level to be considered a list.

           +o   For the nn==22 option, a list is considered 'complex' if it is part of a nested list structure which spans
               multiple lines in the input file.

           +o   If multiple opening tokens have been 'welded' together with the --wwnn parameter, then this parameter has
               no effect.

           +o   The indentation of the braces will normally be one level of continuation indentation by default.  This
               can be changed with the parameter --bbbbhhbbii==nn in the next section.

           +o   Similar flags for controlling parens and square brackets are given in the subsequent section.

       --bbbbhhbbii==nn,  ----bbrreeaakk--bbeeffoorree--hhaasshh--bbrraaccee--aanndd--iinnddeenntt==nn
           This flag is a companion to --bbbbhhbb==nn for controlling the indentation of an opening hash brace which is placed
           on a new line by that parameter.  The indentation is as follows:

             -bbhbi=0 one continuation level [default]
             -bbhbi=1 outdent by one continuation level
             -bbhbi=2 indent one full indentation level

           For example:

               # perltidy -bbhb=3 -bbhbi=1
               $romanNumerals =
               {
                   one   => 'I',
                   two   => 'II',
                   three => 'III',
                   four  => 'IV',
               };

               # perltidy -bbhb=3 -bbhbi=2
               $romanNumerals =
                   {
                   one   => 'I',
                   two   => 'II',
                   three => 'III',
                   four  => 'IV',
                   };

           Note that this parameter has no effect unless --bbbbhhbb==nn is also set.

       --bbbbssbb==nn,  ----bbrreeaakk--bbeeffoorree--ssqquuaarree--bbrraacckkeett==nn
           This flag is similar to the flag described above, except it applies to lists contained within square
           brackets.

             -bbsb=0 never break [default]
             -bbsb=1 stable: break if the input script had a break
             -bbsb=2 break if list is 'complex' (part of nested list structure)
             -bbsb=3 always break

       --bbbbssbbii==nn,  ----bbrreeaakk--bbeeffoorree--ssqquuaarree--bbrraacckkeett--aanndd--iinnddeenntt==nn
           This flag is a companion to --bbbbssbb==nn for controlling the indentation of an opening square bracket which is
           placed on a new line by that parameter.  The indentation is as follows:

             -bbsbi=0 one continuation level [default]
             -bbsbi=1 outdent by one continuation level
             -bbsbi=2 indent one full indentation level

       --bbbbpp==nn,  ----bbrreeaakk--bbeeffoorree--ppaarreenn==nn
           This flag is similar to --bbbbhhbb==nn, described above, except it applies to lists contained within parens.

             -bbp=0 never break [default]
             -bbp=1 stable: break if the input script had a break
             -bpb=2 break if list is 'complex' (part of nested list structure)
             -bbp=3 always break

       --bbbbppii==nn,  ----bbrreeaakk--bbeeffoorree--ppaarreenn--aanndd--iinnddeenntt==nn
           This flag is a companion to --bbbbpp==nn for controlling the indentation of an opening paren which is placed on a
           new line by that parameter.  The indentation is as follows:

             -bbpi=0 one continuation level [default]
             -bbpi=1 outdent by one continuation level
             -bbpi=2 indent one full indentation level

       --wwnn,  ----wweelldd--nneesstteedd--ccoonnttaaiinneerrss
           The --wwnn flag causes closely nested pairs of opening and closing container symbols (curly braces, brackets,
           or parens) to be "welded" together, meaning that they are treated as if combined into a single unit, with
           the indentation of the innermost code reduced to be as if there were just a single container symbol.

           For example:

                   # default formatting
                   do {
                       {
                           next if $x == $y;
                       }
                   } until $x++ > $z;

                   # perltidy -wn
                   do { {
                       next if $x == $y;
                   } } until $x++ > $z;

           When this flag is set perltidy makes a preliminary pass through the file and identifies all nested pairs of
           containers.  To qualify as a nested pair, the closing container symbols must be immediately adjacent and the
           opening symbols must either (1) be adjacent as in the above example, or (2) have an anonymous sub
           declaration following an outer opening container symbol which is not a code block brace, or (3) have an
           outer opening paren separated from the inner opening symbol by any single non-container symbol or something
           that looks like a function evaluation, as illustrated in the next examples.

           Any container symbol may serve as both the inner container of one pair and as the outer container of an
           adjacent pair. Consequently, any number of adjacent opening or closing symbols may join together in weld.
           For example, here are three levels of wrapped function calls:

                   # default formatting
                   my (@date_time) = Localtime(
                       Date_to_Time(
                           Add_Delta_DHMS(
                               $year, $month,  $day, $hour, $minute, $second,
                               '0',   $offset, '0',  '0'
                           )
                       )
                   );

                   # perltidy -wn
                   my (@date_time) = Localtime( Date_to_Time( Add_Delta_DHMS(
                       $year, $month,  $day, $hour, $minute, $second,
                       '0',   $offset, '0',  '0'
                   ) ) );

           Notice how the indentation of the inner lines are reduced by two levels in this case.  This example also
           shows the typical result of this formatting, namely it is a sandwich consisting of an initial opening layer,
           a central section of any complexity forming the "meat" of the sandwich, and a final closing layer.  This
           predictable structure helps keep the compacted structure readable.

           The inner sandwich layer is required to be at least one line thick.  If this cannot be achieved, welding
           does not occur.  This constraint can cause formatting to take a couple of iterations to stabilize when it is
           first applied to a script. The --ccoonnvv flag can be used to insure that the final format is achieved in a
           single run.

           Here is an example illustrating a welded container within a welded containers:

                   # default formatting
                   $x->badd(
                       bmul(
                           $class->new(
                               abs(
                                   $sx * int( $xr->numify() ) & $sy * int( $yr->numify() )
                               )
                           ),
                           $m
                       )
                   );

                   # perltidy -wn
                   $x->badd( bmul(
                       $class->new( abs(
                           $sx * int( $xr->numify() ) & $sy * int( $yr->numify() )
                       ) ),
                       $m
                   ) );

           The welded closing tokens are by default on a separate line but this can be modified with the --vvttcc==nn flag
           (described in the next section).  For example, the same example adding --vvttcc==22 is

                   # perltidy -wn -vtc=2
                   $x->badd( bmul(
                       $class->new( abs(
                           $sx * int( $xr->numify() ) & $sy * int( $yr->numify() ) ) ),
                       $m ) );

           This format option is quite general but there are some limitations.

           One limitation is that any line length limit still applies and can cause long welded sections to be broken
           into multiple lines.

           Another limitation is that an opening symbol which delimits quoted text cannot be included in a welded pair.
           This is because quote delimiters are treated specially in perltidy.

           Finally, the stacking of containers defined by this flag have priority over any other container stacking
           flags.  This is because any welding is done first.

       --wwnnxxll==ss,  ----wweelldd--nneesstteedd--eexxcclluussiioonn--lliisstt
           The --wwnnxxll==ss flag provides some control over the types of containers which can be welded.  The --wwnn flag by
           default is "greedy" in welding adjacent containers.  If it welds more types of containers than desired, this
           flag provides a capability to reduce the amount of welding by specifying a list of things which should nnoott
           be welded.

           The logic in perltidy to apply this is straightforward.  As each container token is being considered for
           joining a weld, any exclusion rules are consulted and used to reject the weld if necessary.

           This list is a string with space-separated items.  Each item consists of up to three pieces of information:
           (1) an optional position, (2) an optional preceding type, and (3) a container type.

           The only required piece of information is a container type, which is one of '(', '[', '{' or 'q'.  The first
           three of these are container tokens and the last represents a quoted list.  For example the string

             -wnxl='[ { q'

           means do NNOOTT include square-bracets, braces, or quotes in any welds.  The only unspecified container is '(',
           so this string means that only welds involving parens will be made.

           To illustrate, following welded snippet consists of a chain of three welded containers with types '(' '['
           and 'q':

               # perltidy -wn
               skip_symbols( [ qw(
                   Perl_dump_fds
                   Perl_ErrorNo
                   Perl_GetVars
                   PL_sys_intern
               ) ] );

           Even though the qw term uses parens as the quote delimiter, it has a special type 'q' here. If it appears in
           a weld it always appears at the end of the welded chain.

           Any of the container types '[', '{', and '(' may be prefixed with a position indicator which is either '^',
           to indicate the first token of a welded sequence, or '.', to indicate an interior token of a welded
           sequence.  (Since a quoted string 'q' always ends a chain it does need a position indicator).

           For example, if we do not want a sequence of welded containers to start with a square bracket we could use

             -wnxl='^['

           In the above snippet, there is a square bracket but it does not start the chain, so the formatting would be
           unchanged if it were formatted with this restriction.

           A third optional item of information which can be given is an alphanumeric letter which is used to limit the
           selection further depending on the type of token immediately before the container.  If given, it goes just
           before the container symbol.  The possible letters are currently 'k', 'K', 'f', 'F', 'w', and 'W', with
           these meanings:

            'k' matches if the previous nonblank token is a perl builtin keyword (such as 'if', 'while'),
            'K' matches if 'k' does not, meaning that the previous token is not a keyword.
            'f' matches if the previous token is a function other than a keyword.
            'F' matches if 'f' does not.
            'w' matches if either 'k' or 'f' match.
            'W' matches if 'w' does not.

           For example, compare

                   # perltidy -wn
                   if ( defined( $_Cgi_Query{
                       $Config{'methods'}{'authentication'}{'remote'}{'cgi'}{'username'}
                   } ) )

           with

                   # perltidy -wn -wnxl='^K( {'
                   if ( defined(
                       $_Cgi_Query{ $Config{'methods'}{'authentication'}{'remote'}{'cgi'}
                             {'username'} }
                   ) )

           The first case does maximum welding. In the second case the leading paren is retained by the rule (it would
           have been rejected if preceded by a non-keyword) but the curly brace is rejected by the rule.

           Here are some additional example strings and their meanings:

               '^('   - the weld must not start with a paren
               '.('   - the second and later tokens may not be parens
               '.w('  - the second and later tokens may not keyword or function call parens
               '('    - no parens in a weld
               '^K('  - exclude a leading paren preceded by a non-keyword
               '.k('  - exclude a secondary paren preceded by a keyword
               '[ {'  - exclude all brackets and braces
               '[ ( ^K{' - exclude everything except nested structures like do {{  ... }}

       VVeerrttiiccaall ttiigghhttnneessss of non-block curly braces, parentheses, and square brackets.
           These parameters control what shall be called vertical tightness.  Here are the main points:

           +o   Opening tokens (except for block braces) are controlled by --vvtt==nn, or ----vveerrttiiccaall--ttiigghhttnneessss==nn, where

                -vt=0 always break a line after opening token (default).
                -vt=1 do not break unless this would produce more than one
                        step in indentation in a line.
                -vt=2 never break a line after opening token

           +o   You must also use the --llpp flag when you use the --vvtt flag; the reason is explained below.

           +o   Closing tokens (except for block braces) are controlled by --vvttcc==nn, or ----vveerrttiiccaall--ttiigghhttnneessss--cclloossiinngg==nn,
               where

                -vtc=0 always break a line before a closing token (default),
                -vtc=1 do not break before a closing token which is followed
                       by a semicolon or another closing token, and is not in
                       a list environment.
                -vtc=2 never break before a closing token.
                -vtc=3 Like -vtc=1 except always break before a closing token
                       if the corresponding opening token follows an = or =>.

               The rules for --vvttcc==11 and --vvttcc==33 are designed to maintain a reasonable balance between tightness and
               readability in complex lists.

           +o   Different controls may be applied to different token types, and it is also possible to control block
               braces; see below.

           +o   Finally, please note that these vertical tightness flags are merely hints to the formatter, and it
               cannot always follow them.  Things which make it difficult or impossible include comments, blank lines,
               blocks of code within a list, and possibly the lack of the --llpp parameter.  Also, these flags may be
               ignored for very small lists (2 or 3 lines in length).

           Here are some examples:

               # perltidy -lp -vt=0 -vtc=0
               %romanNumerals = (
                                  one   => 'I',
                                  two   => 'II',
                                  three => 'III',
                                  four  => 'IV',
               );

               # perltidy -lp -vt=1 -vtc=0
               %romanNumerals = ( one   => 'I',
                                  two   => 'II',
                                  three => 'III',
                                  four  => 'IV',
               );

               # perltidy -lp -vt=1 -vtc=1
               %romanNumerals = ( one   => 'I',
                                  two   => 'II',
                                  three => 'III',
                                  four  => 'IV', );

               # perltidy -vtc=3
               my_function(
                   one   => 'I',
                   two   => 'II',
                   three => 'III',
                   four  => 'IV', );

               # perltidy -vtc=3
               %romanNumerals = (
                   one   => 'I',
                   two   => 'II',
                   three => 'III',
                   four  => 'IV',
               );

           In the last example for --vvttcc==33, the opening paren is preceded by an equals so the closing paren is placed on
           a new line.

           The difference between --vvtt==11 and --vvtt==22 is shown here:

               # perltidy -lp -vt=1
               $init->add(
                           mysprintf( "(void)find_threadsv(%s);",
                                      cstring( $threadsv_names[ $op->targ ] )
                           )
               );

               # perltidy -lp -vt=2
               $init->add( mysprintf( "(void)find_threadsv(%s);",
                                      cstring( $threadsv_names[ $op->targ ] )
                           )
               );

           With --vvtt==11, the line ending in "add(" does not combine with the next line because the next line is not
           balanced.  This can help with readability, but --vvtt==22 can be used to ignore this rule.

           The tightest, and least readable, code is produced with both "-vt=2" and "-vtc=2":

               # perltidy -lp -vt=2 -vtc=2
               $init->add( mysprintf( "(void)find_threadsv(%s);",
                                      cstring( $threadsv_names[ $op->targ ] ) ) );

           Notice how the code in all of these examples collapses vertically as --vvtt increases, but the indentation
           remains unchanged.  This is because perltidy implements the --vvtt parameter by first formatting as if --vvtt==00,
           and then simply overwriting one output line on top of the next, if possible, to achieve the desired vertical
           tightness.  The --llpp indentation style has been designed to allow this vertical collapse to occur, which is
           why it is required for the --vvtt parameter.

           The --vvtt==nn and --vvttcc==nn parameters apply to each type of container token.  If desired, vertical tightness
           controls can be applied independently to each of the closing container token types.

           The parameters for controlling parentheses are --ppvvtt==nn or ----ppaarreenn--vveerrttiiccaall--ttiigghhttnneessss==nn, and --ppvvttcc==nn or
           ----ppaarreenn--vveerrttiiccaall--ttiigghhttnneessss--cclloossiinngg==nn.

           Likewise, the parameters for square brackets are --ssbbvvtt==nn or ----ssqquuaarree--bbrraacckkeett--vveerrttiiccaall--ttiigghhttnneessss==nn, and
           --ssbbvvttcc==nn or ----ssqquuaarree--bbrraacckkeett--vveerrttiiccaall--ttiigghhttnneessss--cclloossiinngg==nn.

           Finally, the parameters for controlling non-code block braces are --bbvvtt==nn or ----bbrraaccee--vveerrttiiccaall--ttiigghhttnneessss==nn,
           and --bbvvttcc==nn or ----bbrraaccee--vveerrttiiccaall--ttiigghhttnneessss--cclloossiinngg==nn.

           In fact, the parameter --vvtt==nn is actually just an abbreviation for --ppvvtt==nn --bbvvtt==nn ssbbvvtt==nn, and likewise --vvttcc==nn
           is an abbreviation for --ppvvttcc==nn --bbvvttcc==nn --ssbbvvttcc==nn.

       --bbbbvvtt==nn or ----bblloocckk--bbrraaccee--vveerrttiiccaall--ttiigghhttnneessss==nn
           The --bbbbvvtt==nn flag is just like the --vvtt==nn flag but applies to opening code block braces.

            -bbvt=0 break after opening block brace (default).
            -bbvt=1 do not break unless this would produce more than one
                    step in indentation in a line.
            -bbvt=2 do not break after opening block brace.

           It is necessary to also use either --bbll or --bbllii for this to work, because, as with other vertical tightness
           controls, it is implemented by simply overwriting a line ending with an opening block brace with the
           subsequent line.  For example:

               # perltidy -bli -bbvt=0
               if ( open( FILE, "< $File" ) )
                 {
                   while ( $File = <FILE> )
                     {
                       $In .= $File;
                       $count++;
                     }
                   close(FILE);
                 }

               # perltidy -bli -bbvt=1
               if ( open( FILE, "< $File" ) )
                 { while ( $File = <FILE> )
                     { $In .= $File;
                       $count++;
                     }
                   close(FILE);
                 }

           By default this applies to blocks associated with keywords iiff, eellssiiff, eellssee, uunnlleessss, ffoorr, ffoorreeaacchh, ssuubb,
           wwhhiillee, uunnttiill, and also with a preceding label.  This can be changed with the parameter --bbbbvvttll==ssttrriinngg, or
           ----bblloocckk--bbrraaccee--vveerrttiiccaall--ttiigghhttnneessss--lliisstt==ssttrriinngg, where ssttrriinngg is a space-separated list of block types.  For
           more information on the possible values of this string, see "Specifying Block Types"

           For example, if we want to just apply this style to "if", "elsif", and "else" blocks, we could use "perltidy
           -bli -bbvt=1 -bbvtl='if elsif else'".

           There is no vertical tightness control for closing block braces; with one exception they will be placed on
           separate lines.  The exception is that a cascade of closing block braces may be stacked on a single line.
           See --ssccbbbb.

       --ssoott,  ----ssttaacckk--ooppeenniinngg--ttookkeennss and related flags
           The --ssoott flag tells perltidy to "stack" opening tokens when possible to avoid lines with isolated opening
           tokens.

           For example:

               # default
               $opt_c = Text::CSV_XS->new(
                   {
                       binary       => 1,
                       sep_char     => $opt_c,
                       always_quote => 1,
                   }
               );

               # -sot
               $opt_c = Text::CSV_XS->new( {
                       binary       => 1,
                       sep_char     => $opt_c,
                       always_quote => 1,
                   }
               );

           For detailed control of individual closing tokens the following controls can be used:

             -sop  or --stack-opening-paren
             -sohb or --stack-opening-hash-brace
             -sosb or --stack-opening-square-bracket
             -sobb or --stack-opening-block-brace

           The flag --ssoott is an abbreviation for --ssoopp --ssoohhbb --ssoossbb.

           The flag --ssoobbbb is an abbreviation for --bbbbvvtt==22 --bbbbvvttll==''**''.  This will case a cascade of opening block braces
           to appear on a single line, although this an uncommon occurrence except in test scripts.

       --sscctt,  ----ssttaacckk--cclloossiinngg--ttookkeennss and related flags
           The --sscctt flag tells perltidy to "stack" closing tokens when possible to avoid lines with isolated closing
           tokens.

           For example:

               # default
               $opt_c = Text::CSV_XS->new(
                   {
                       binary       => 1,
                       sep_char     => $opt_c,
                       always_quote => 1,
                   }
               );

               # -sct
               $opt_c = Text::CSV_XS->new(
                   {
                       binary       => 1,
                       sep_char     => $opt_c,
                       always_quote => 1,
                   } );

           The --sscctt flag is somewhat similar to the --vvttcc flags, and in some cases it can give a similar result.  The
           difference is that the --vvttcc flags try to avoid lines with leading opening tokens by "hiding" them at the end
           of a previous line, whereas the --sscctt flag merely tries to reduce the number of lines with isolated closing
           tokens by stacking them but does not try to hide them.  For example:

               # -vtc=2
               $opt_c = Text::CSV_XS->new(
                   {
                       binary       => 1,
                       sep_char     => $opt_c,
                       always_quote => 1, } );

           For detailed control of the stacking of individual closing tokens the following controls can be used:

             -scp  or --stack-closing-paren
             -schb or --stack-closing-hash-brace
             -scsb or --stack-closing-square-bracket
             -scbb or --stack-closing-block-brace

           The flag --sscctt is an abbreviation for stacking the non-block closing tokens, --ssccpp --sscchhbb --ssccssbb.

           Stacking of closing block braces, --ssccbbbb, causes a cascade of isolated closing block braces to be combined
           into a single line as in the following example:

               # -scbb:
               for $w1 (@w1) {
                   for $w2 (@w2) {
                       for $w3 (@w3) {
                           for $w4 (@w4) {
                               push( @lines, "$w1 $w2 $w3 $w4\n" );
                           } } } }

           To simplify input even further for the case in which both opening and closing non-block containers are
           stacked, the flag --ssaacc or ----ssttaacckk--aallll--ccoonnttaaiinneerrss is an abbreviation for --ssoott --sscctt.

           Please note that if both opening and closing tokens are to be stacked, then the newer flag
           --wweelldd--nneesstteedd--ccoonnttaaiinneerrss may be preferable because it insures that stacking is always done symmetrically.  It
           also removes an extra level of unnecessary indentation within welded containers.  It is able to do this
           because it works on formatting globally rather than locally, as the --ssoott and --sscctt flags do.

       --ddnnll,  ----ddeelleettee--oolldd--nneewwlliinneess
           By default, perltidy first deletes all old line break locations, and then it looks for good break points to
           match the desired line length.  Use --nnddnnll or  ----nnooddeelleettee--oolldd--nneewwlliinneess to force perltidy to retain all old
           line break points.

       --aannll,  ----aadddd--nneewwlliinneess
           By default, perltidy will add line breaks when necessary to create continuations of long lines and to
           improve the script appearance.  Use --nnaannll or ----nnooaadddd--nneewwlliinneess to prevent any new line breaks.

           This flag does not prevent perltidy from eliminating existing line breaks; see ----ffrreeeezzee--nneewwlliinneess to
           completely prevent changes to line break points.

       CCoonnttrroolllliinngg wwhheetthheerr ppeerrllttiiddyy bbrreeaakkss bbeeffoorree oorr aafftteerr ooppeerraattoorrss
           Four command line parameters provide some control over whether a line break should be before or after
           specific token types.  Two parameters give detailed control:

           --wwbbaa==ss or ----wwaanntt--bbrreeaakk--aafftteerr==ss, and

           --wwbbbb==ss or ----wwaanntt--bbrreeaakk--bbeeffoorree==ss.

           These parameters are each followed by a quoted string, ss, containing a list of token types (separated only
           by spaces).  No more than one of each of these parameters should be specified, because repeating a command-
           line parameter always overwrites the previous one before perltidy ever sees it.

           By default, perltidy breaks aafftteerr these token types:
             % + - * / x != == >= <= =~ !~ < >  | &
             = **= += *= &= <<= &&= -= /= |= >>= ||= //= .= %= ^= x=

           And perltidy breaks bbeeffoorree these token types by default:
             . << >> -> && || //

           To illustrate, to cause a break after a concatenation operator, '.', rather than before it, the command line
           would be

             -wba="."

           As another example, the following command would cause a break before math operators '+', '-', '/', and '*':

             -wbb="+ - / *"

           These commands should work well for most of the token types that perltidy uses (use ----dduummpp--ttookkeenn--ttyyppeess for a
           list).  Also try the --DD flag on a short snippet of code and look at the .DEBUG file to see the tokenization.
           However, for a few token types there may be conflicts with hardwired logic which cause unexpected results.
           One example is curly braces, which should be controlled with the parameter bbll provided for that purpose.

           WWAARRNNIINNGG Be sure to put these tokens in quotes to avoid having them misinterpreted by your command shell.

           Two additional parameters are available which, though they provide no further capability, can simplify input
           are:

           --bbaaaaoo or ----bbrreeaakk--aafftteerr--aallll--ooppeerraattoorrss,

           --bbbbaaoo or ----bbrreeaakk--bbeeffoorree--aallll--ooppeerraattoorrss.

           The -baao sets the default to be to break after all of the following operators:

               % + - * / x != == >= <= =~ !~ < > | &
               = **= += *= &= <<= &&= -= /= |= >>= ||= //= .= %= ^= x=
               . : ? && || and or err xor

           and the --bbbbaaoo flag sets the default to break before all of these operators.  These can be used to define an
           initial break preference which can be fine-tuned with the --wwbbaa and --wwbbbb flags.  For example, to break before
           all operators except an == one could use --bbao -wba='=' rather than listing every single perl operator
           except == on a -wbb flag.

   CCoonnttrroolllliinngg LLiisstt FFoorrmmaattttiinngg
       Perltidy attempts to format lists of comma-separated values in tables which look good.  Its default algorithms
       usually work well, but sometimes they don't.  In this case, there are several methods available to control list
       formatting.

       A very simple way to prevent perltidy from changing the line breaks within a comma-separated list of values is
       to insert a blank line, comment, or side-comment anywhere between the opening and closing parens (or braces or
       brackets).   This causes perltidy to skip over its list formatting logic.  (The reason is that any of these
       items put a constraint on line breaks, and perltidy needs complete control over line breaks within a container
       to adjust a list layout).  For example, let us consider

           my @list = (1,
                       1, 1,
                       1, 2, 1,
                       1, 3, 3, 1,
                       1, 4, 6, 4, 1,);

       The default formatting, which allows a maximum line length of 80, will flatten this down to one line:

           # perltidy (default)
           my @list = ( 1, 1, 1, 1, 2, 1, 1, 3, 3, 1, 1, 4, 6, 4, 1, );

       This formatting loses important information.  If we place a side comment on one of the lines, for example, we
       get the following result with with default formatting parameters:

           my @list = (
               1,    # a side comment, comment, or blank keeps list intact
               1, 1,
               1, 2, 1,
               1, 3, 3, 1,
               1, 4, 6, 4, 1,
           );

       We could achieve the same result with a blank line or full comment anywhere between the opening and closing
       parens.

       For another possibility see the -fs flag in "Skipping Selected Sections of Code".

       --bboocc,  ----bbrreeaakk--aatt--oolldd--ccoommmmaa--bbrreeaakkppooiinnttss
           The --bboocc flag is another way to prevent comma-separated lists from being reformatted.  Using --bboocc on the
           above example, plus additional flags to retain the original style, yields

               # perltidy -boc -lp -pt=2 -vt=1 -vtc=1
               my @list = (1,
                           1, 1,
                           1, 2, 1,
                           1, 3, 3, 1,
                           1, 4, 6, 4, 1,);

           A disadvantage of this flag is that all tables in the file must already be nicely formatted.

       --mmfftt==nn,  ----mmaaxxiimmuumm--ffiieellddss--ppeerr--ttaabbllee==nn
           If the computed number of fields for any table exceeds nn, then it will be reduced to nn.  The default value
           for nn is a large number, 40.  While this value should probably be left unchanged as a general rule, it might
           be used on a small section of code to force a list to have a particular number of fields per line, and then
           either the --bboocc flag could be used to retain this formatting, or a single comment could be introduced
           somewhere to freeze the formatting in future applications of perltidy.

               # perltidy -mft=2
               @month_of_year = (
                   'Jan', 'Feb',
                   'Mar', 'Apr',
                   'May', 'Jun',
                   'Jul', 'Aug',
                   'Sep', 'Oct',
                   'Nov', 'Dec'
               );

       --ccaabb==nn,  ----ccoommmmaa--aarrrrooww--bbrreeaakkppooiinnttss==nn
           A comma which follows a comma arrow, '=>', is given special consideration.  In a long list, it is common to
           break at all such commas.  This parameter can be used to control how perltidy breaks at these commas.
           (However, it will have no effect if old comma breaks are being forced because --bboocc is used).  The possible
           values of nn are:

            n=0 break at all commas after =>
            n=1 stable: break at all commas after => if container is open,
                EXCEPT FOR one-line containers
            n=2 break at all commas after =>, BUT try to form the maximum
                one-line container lengths
            n=3 do not treat commas after => specially at all
            n=4 break everything: like n=0 but ALSO break a short container with
                a => not followed by a comma when -vt=0 is used
            n=5 stable: like n=1 but ALSO break at open one-line containers when
                -vt=0 is used (default)

           For example, given the following single line, perltidy by default will not add any line breaks because it
           would break the existing one-line container:

               bless { B => $B, Root => $Root } => $package;

           Using --ccaabb==00 will force a break after each comma-arrow item:

               # perltidy -cab=0:
               bless {
                   B    => $B,
                   Root => $Root
               } => $package;

           If perltidy is subsequently run with this container broken, then by default it will break after each '=>'
           because the container is now broken.  To reform a one-line container, the parameter --ccaabb==22 could be used.

           The flag --ccaabb==33 can be used to prevent these commas from being treated specially.  In this case, an item
           such as "01" => 31 is treated as a single item in a table.  The number of fields in this table will be
           determined by the same rules that are used for any other table.  Here is an example.

               # perltidy -cab=3
               my %last_day = (
                   "01" => 31, "02" => 29, "03" => 31, "04" => 30,
                   "05" => 31, "06" => 30, "07" => 31, "08" => 31,
                   "09" => 30, "10" => 31, "11" => 30, "12" => 31
               );

   RReettaaiinniinngg oorr IIggnnoorriinngg EExxiissttiinngg LLiinnee BBrreeaakkss
       Several additional parameters are available for controlling the extent to which line breaks in the input script
       influence the output script.  In most cases, the default parameter values are set so that, if a choice is
       possible, the output style follows the input style.  For example, if a short logical container is broken in the
       input script, then the default behavior is for it to remain broken in the output script.

       Most of the parameters in this section would only be required for a one-time conversion of a script from short
       container lengths to longer container lengths.  The opposite effect, of converting long container lengths to
       shorter lengths, can be obtained by temporarily using a short maximum line length.

       --bbooll,  ----bbrreeaakk--aatt--oolldd--llooggiiccaall--bbrreeaakkppooiinnttss
           By default, if a logical expression is broken at a "&&", "||", "and", or "or", then the container will
           remain broken.  Also, breaks at internal keywords "if" and "unless" will normally be retained.  To prevent
           this, and thus form longer lines, use --nnbbooll.

           Please note that this flag does not duplicate old logical breakpoints.  They are merely used as a hint with
           this flag that a statement should remain broken.  Without this flag, perltidy will normally try to combine
           relatively short expressions into a single line.

           For example, given this snippet:

               return unless $cmd = $cmd || ($dot
                   && $Last_Shell) || &prompt('|');

               # perltidy -bol [default]
               return
                 unless $cmd = $cmd
                 || ( $dot
                   && $Last_Shell )
                 || &prompt('|');

               # perltidy -nbol
               return unless $cmd = $cmd || ( $dot && $Last_Shell ) || &prompt('|');

       --bboomm,  ----bbrreeaakk--aatt--oolldd--mmeetthhoodd--bbrreeaakkppooiinnttss
           By default, a method call arrow "->" is considered a candidate for a breakpoint, but method chains will fill
           to the line width before a break is considered.  With --bboomm, breaks before the arrow are preserved, so if you
           have preformatted a method chain:

             my $q = $rs
               ->related_resultset('CDs')
               ->related_resultset('Tracks')
               ->search({
                 'track.id' => {-ident => 'none_search.id'},
               })->as_query;

           It will kkeeeepp these breaks, rather than become this:

             my $q = $rs->related_resultset('CDs')->related_resultset('Tracks')->search({
                 'track.id' => {-ident => 'none_search.id'},
               })->as_query;

           This flag will also look for and keep a 'cuddled' style of calls, in which lines begin with a closing paren
           followed by a call arrow, as in this example:

             # perltidy -bom -wn
             my $q = $rs->related_resultset(
                 'CDs'
             )->related_resultset(
                 'Tracks'
             )->search( {
                 'track.id' => { -ident => 'none_search.id' },
             } )->as_query;

           You may want to include the --wweelldd--nneesstteedd--ccoonnttaaiinneerrss flag in this case to keep nested braces and parens
           together, as in the last line.

       --bbooss,  ----bbrreeaakk--aatt--oolldd--sseemmiiccoolloonn--bbrreeaakkppooiinnttss
           Semicolons are normally placed at the end of a statement.  This means that formatted lines do not normally
           begin with semicolons.  If the input stream has some lines which begin with semicolons, these can be
           retained by setting this flag.  For example, consider the following two-line input snippet:

             $z = sqrt($x**2 + $y**2)
             ;

           The default formatting will be:

             $z = sqrt( $x**2 + $y**2 );

           The result using ppeerrllttiiddyy --bbooss keeps the isolated semicolon:

             $z = sqrt( $x**2 + $y**2 )
               ;

           The default is not to do this, --nnbbooss.

       --bbookk,  ----bbrreeaakk--aatt--oolldd--kkeeyywwoorrdd--bbrreeaakkppooiinnttss
           By default, perltidy will retain a breakpoint before keywords which may return lists, such as "sort" and
           <map>.  This allows chains of these operators to be displayed one per line.  Use --nnbbookk to prevent retaining
           these breakpoints.

       --bboott,  ----bbrreeaakk--aatt--oolldd--tteerrnnaarryy--bbrreeaakkppooiinnttss
           By default, if a conditional (ternary) operator is broken at a ":", then it will remain broken.  To prevent
           this, and thereby form longer lines, use --nnbboott.

       --bbooaa,  ----bbrreeaakk--aatt--oolldd--aattttrriibbuuttee--bbrreeaakkppooiinnttss
           By default, if an attribute list is broken at a ":" in the source file, then it will remain broken.  For
           example, given the following code, the line breaks at the ':'s will be retained:

                               my @field
                                 : field
                                 : Default(1)
                                 : Get('Name' => 'foo') : Set('Name');

           If the attributes are on a single line in the source code then they will remain on a single line if
           possible.

           To prevent this, and thereby always form longer lines, use --nnbbooaa.

       KKeeeeppiinngg oolldd bbrreeaakkppooiinnttss aatt ssppeecciiffiicc ttookkeenn ttyyppeess
           Two command line parameters provide detailed control over whether perltidy should keep an old line break
           before or after a specific token type:

           --kkbbbb==ss or ----kkeeeepp--oolldd--bbrreeaakkppooiinnttss--bbeeffoorree==ss, and

           --kkbbaa==ss or ----kkeeeepp--oolldd--bbrreeaakkppooiinnttss--aafftteerr==ss

           These parameters are each followed by a quoted string, ss, containing a list of token types (separated only
           by spaces).  No more than one of each of these parameters should be specified, because repeating a command-
           line parameter always overwrites the previous one before perltidy ever sees it.

           For example, -kbb='=>' means that if an input line begins with a '=>' then the output script should also
           have a line break before that token.

           For example, given the script:

               method 'foo'
                 => [ Int, Int ]
                 => sub {
                   my ( $self, $x, $y ) = ( shift, @_ );
                   ...;
                 };

               # perltidy [default]
               method 'foo' => [ Int, Int ] => sub {
                   my ( $self, $x, $y ) = ( shift, @_ );
                   ...;
               };

               # perltidy -kbb='=>'
               method 'foo'
                 => [ Int, Int ]
                 => sub {
                   my ( $self, $x, $y ) = ( shift, @_ );
                   ...;
                 };

       --iioobb,  ----iiggnnoorree--oolldd--bbrreeaakkppooiinnttss
           Use this flag to tell perltidy to ignore existing line breaks to the maximum extent possible.  This will
           tend to produce the longest possible containers, regardless of type, which do not exceed the line length
           limit. But please note that this parameter has priority over all other parameters requesting that certain
           old breakpoints be kept.

       --kkiiss,  ----kkeeeepp--iinntteerriioorr--sseemmiiccoolloonnss
           Use the --kkiiss flag to prevent breaking at a semicolon if there was no break there in the input file.
           Normally perltidy places a newline after each semicolon which terminates a statement unless several
           statements are contained within a one-line brace block.  To illustrate, consider the following input lines:

               dbmclose(%verb_delim); undef %verb_delim;
               dbmclose(%expanded); undef %expanded;

           The default is to break after each statement, giving

               dbmclose(%verb_delim);
               undef %verb_delim;
               dbmclose(%expanded);
               undef %expanded;

           With ppeerrllttiiddyy --kkiiss the multiple statements are retained:

               dbmclose(%verb_delim); undef %verb_delim;
               dbmclose(%expanded);   undef %expanded;

           The statements are still subject to the specified value of mmaaxxiimmuumm--lliinnee--lleennggtthh and will be broken if this
           maximum is exceeded.

   BBllaannkk LLiinnee CCoonnttrrooll
       Blank lines can improve the readability of a script if they are carefully placed.  Perltidy has several commands
       for controlling the insertion, retention, and removal of blank lines.

       --ffbbll,  ----ffrreeeezzee--bbllaannkk--lliinneess
           Set --ffbbll if you want to the blank lines in your script to remain exactly as they are.  The rest of the
           parameters in this section may then be ignored.  (Note: setting the --ffbbll flag is equivalent to setting
           --mmbbll==00 and --kkbbll==22).

       --bbbbcc,  ----bbllaannkkss--bbeeffoorree--ccoommmmeennttss
           A blank line will be introduced before a full-line comment.  This is the default.  Use --nnbbbbcc or
           ----nnoobbllaannkkss--bbeeffoorree--ccoommmmeennttss to prevent such blank lines from being introduced.

       --bbllbbss==nn,  ----bbllaannkk--lliinneess--bbeeffoorree--ssuubbss==nn
           The parameter --bbllbbss==nn requests that least nn blank lines precede a sub definition which does not follow a
           comment and which is more than one-line long.  The default is <-blbs=1>.  BBEEGGIINN and EENNDD blocks are included.

           The requested number of blanks statement will be inserted regardless of the value of
           ----mmaaxxiimmuumm--ccoonnsseeccuuttiivvee--bbllaannkk--lliinneess==nn (--mmbbll==nn) with the exception that if --mmbbll==00 then no blanks will be
           output.

           This parameter interacts with the value kk of the parameter ----mmaaxxiimmuumm--ccoonnsseeccuuttiivvee--bbllaannkk--lliinneess==kk (--mmbbll==kk) as
           follows:

           1. If --mmbbll==00 then no blanks will be output.  This allows all blanks to be suppressed with a single
           parameter.  Otherwise,

           2. If the number of old blank lines in the script is less than nn then additional blanks will be inserted to
           make the total nn regardless of the value of --mmbbll==kk.

           3. If the number of old blank lines in the script equals or exceeds nn then this parameter has no effect,
           however the total will not exceed value specified on the --mmbbll==kk flag.

       --bbllbbpp==nn,  ----bbllaannkk--lliinneess--bbeeffoorree--ppaacckkaaggeess==nn
           The parameter --bbllbbpp==nn requests that least nn blank lines precede a package which does not follow a comment.
           The default is --bbllbbpp==11.

           This parameter interacts with the value kk of the parameter ----mmaaxxiimmuumm--ccoonnsseeccuuttiivvee--bbllaannkk--lliinneess==kk (--mmbbll==kk) in
           the same way as described for the previous item --bbllbbss==nn.

       --bbbbss,  ----bbllaannkkss--bbeeffoorree--ssuubbss
           For compatibility with previous versions, --bbbbss or ----bbllaannkkss--bbeeffoorree--ssuubbss is equivalent to _-_b_l_b_p_=_1 and _-_b_l_b_s_=_1.

           Likewise, --nnbbbbss or ----nnoobbllaannkkss--bbeeffoorree--ssuubbss is equivalent to _-_b_l_b_p_=_0 and _-_b_l_b_s_=_0.

       --bbbbbb,  ----bbllaannkkss--bbeeffoorree--bblloocckkss
           A blank line will be introduced before blocks of coding delimited by ffoorr, ffoorreeaacchh, wwhhiillee, uunnttiill, and iiff,
           uunnlleessss, in the following circumstances:

           +o   The block is not preceded by a comment.

           +o   The block is not a one-line block.

           +o   The number of consecutive non-blank lines at the current indentation depth is at least --llbbll (see next
               section).

           This is the default.  The intention of this option is to introduce some space within dense coding.  This is
           negated with --nnbbbbbb or  ----nnoobbllaannkkss--bbeeffoorree--bblloocckkss.

       --llbbll==nn ----lloonngg--bblloocckk--lliinnee--ccoouunntt==nn
           This controls how often perltidy is allowed to add blank lines before certain block types (see previous
           section).  The default is 8.  Entering a value of 00 is equivalent to entering a very large number.

       --bbllaaoo==ii or ----bbllaannkk--lliinneess--aafftteerr--ooppeenniinngg--bblloocckk==ii
           This control places a minimum of ii blank lines aafftteerr a line which eennddss with an opening block brace of a
           specified type.  By default, this only applies to the block of a named ssuubb, but this can be changed (see
           --bbllaaooll below).  The default is not to do this (ii==00).

           Please see the note below on using the --bbllaaoo and --bbllbbcc options.

       --bbllbbcc==ii or ----bbllaannkk--lliinneess--bbeeffoorree--cclloossiinngg--bblloocckk==ii
           This control places a minimum of ii blank lines bbeeffoorree a line which bbeeggiinnss with a closing block brace of a
           specified type.  By default, this only applies to the block of a named ssuubb, but this can be changed (see
           --bbllbbccll below).  The default is not to do this (ii==00).

       --bbllaaooll==ss or ----bbllaannkk--lliinneess--aafftteerr--ooppeenniinngg--bblloocckk--lliisstt==ss
           The parameter ss is a list of block type keywords to which the flag --bbllaaoo should apply.  The section
           "Specifying Block Types" explains how to list block types.

       --bbllbbccll==ss or ----bbllaannkk--lliinneess--bbeeffoorree--cclloossiinngg--bblloocckk--lliisstt==ss
           This parameter is a list of block type keywords to which the flag --bbllbbcc should apply.  The section
           "Specifying Block Types" explains how to list block types.

       NNoottee oonn uussiinngg tthhee --bbllaaoo and --bbllbbcc options.
           These blank line controls introduce a certain minimum number of blank lines in the text, but the final
           number of blank lines may be greater, depending on values of the other blank line controls and the number of
           old blank lines.  A consequence is that introducing blank lines with these and other controls cannot be
           exactly undone, so some experimentation with these controls is recommended before using them.

           For example, suppose that for some reason we decide to introduce one blank space at the beginning and ending
           of all blocks.  We could do this using

             perltidy -blao=2 -blbc=2 -blaol='*' -blbcl='*' filename

           Now suppose the script continues to be developed, but at some later date we decide we don't want these
           spaces after all. We might expect that running with the flags --bbllaaoo==00 and --bbllbbcc==00 will undo them.  However,
           by default perltidy retains single blank lines, so the blank lines remain.

           We can easily fix this by telling perltidy to ignore old blank lines by including the added parameter --kkbbll==00
           and rerunning. Then the unwanted blank lines will be gone.  However, this will cause all old blank lines to
           be ignored, perhaps even some that were added by hand to improve formatting. So please be cautious when
           using these parameters.

       --mmbbll==nn ----mmaaxxiimmuumm--ccoonnsseeccuuttiivvee--bbllaannkk--lliinneess==nn
           This parameter specifies the maximum number of consecutive blank lines which will be output within code
           sections of a script.  The default is n=1.  If the input file has more than n consecutive blank lines, the
           number will be reduced to n except as noted above for the --bbllbbpp and --bbllbbss parameters.  If nn==00 then no blank
           lines will be output (unless all old blank lines are retained with the --kkbbll==22 flag of the next section).

           This flag obviously does not apply to pod sections, here-documents, and quotes.

       --kkbbll==nn,  ----kkeeeepp--oolldd--bbllaannkk--lliinneess==nn
           The --kkbbll==nn flag gives you control over how your existing blank lines are treated.

           The possible values of nn are:

            n=0 ignore all old blank lines
            n=1 stable: keep old blanks, but limited by the value of the B<-mbl=n> flag
            n=2 keep all old blank lines, regardless of the value of the B<-mbl=n> flag

           The default is nn==11.

       --ssoobb,  ----sswwaallllooww--ooppttiioonnaall--bbllaannkk--lliinneess
           This is equivalent to kkbbll==00 and is included for compatibility with previous versions.

       --nnssoobb,  ----nnoosswwaallllooww--ooppttiioonnaall--bbllaannkk--lliinneess
           This is equivalent to kkbbll==11 and is included for compatibility with previous versions.

       CCoonnttrroollss ffoorr bbllaannkk lliinneess aarroouunndd lliinneess ooff ccoonnsseeccuuttiivvee kkeeyywwoorrddss

       The parameters in this section provide some control over the placement of blank lines within and around groups
       of statements beginning with selected keywords.  These blank lines are called here kkeeyywwoorrdd ggrroouupp bbllaannkkss, and all
       of the parameters begin with ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss**, or --kkggbb** for short.  The default settings do not employ
       these controls but they can be enabled with the following parameters:

       --kkggbbll==ss or ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss--lliisstt==ss; ss is a quoted string of keywords

       --kkggbbss==ss or ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss--ssiizzee==ss; ss gives the number of keywords required to form a group.

       --kkggbbbb==nn or ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss--bbeeffoorree==nn; nn = (0, 1, or 2) controls a leading blank

       --kkggbbaa==nn or ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss--aafftteerr==nn; nn = (0, 1, or 2) controls a trailing blank

       --kkggbbii or ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss--iinnssiiddee is a switch for adding blanks between subgroups

       --kkggbbdd or ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss--ddeelleettee is a switch for removing initial blank lines between keywords

       --kkggbbrr==nn or ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss--rreeppeeaatt--ccoouunntt==nn can limit the number of times this logic is applied

       In addition, the following abbreviations are available to for simplified usage:

       --kkggbb or ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss is short for --kkggbbbb==22 --kkggbbaa==22 kkggbbii

       --nnkkggbb or ----nnookkeeyywwoorrdd--ggrroouupp--bbllaannkkss, is short for --kkggbbbb==11 --kkggbbaa==11 nnkkggbbii

       Before describing the meaning of the parameters in detail let us look at an example which is formatted with
       default parameter settings.

               print "Entering test 2\n";
               use Test;
               use Encode qw(from_to encode decode
                 encode_utf8 decode_utf8
                 find_encoding is_utf8);
               use charnames qw(greek);
               my @encodings     = grep( /iso-?8859/, Encode::encodings() );
               my @character_set = ( '0' .. '9', 'A' .. 'Z', 'a' .. 'z' );
               my @source        = qw(ascii iso8859-1 cp1250);
               my @destiny       = qw(cp1047 cp37 posix-bc);
               my @ebcdic_sets   = qw(cp1047 cp37 posix-bc);
               my $str           = join( '', map( chr($_), 0x20 .. 0x7E ) );
               return unless ($str);

       using ppeerrllttiiddyy --kkggbb gives:

               print "Entering test 2\n";
                                             <----------this blank controlled by -kgbb
               use Test;
               use Encode qw(from_to encode decode
                 encode_utf8 decode_utf8
                 find_encoding is_utf8);
               use charnames qw(greek);
                                             <---------this blank controlled by -kgbi
               my @encodings     = grep( /iso-?8859/, Encode::encodings() );
               my @character_set = ( '0' .. '9', 'A' .. 'Z', 'a' .. 'z' );
               my @source        = qw(ascii iso8859-1 cp1250);
               my @destiny       = qw(cp1047 cp37 posix-bc);
               my @ebcdic_sets   = qw(cp1047 cp37 posix-bc);
               my $str           = join( '', map( chr($_), 0x20 .. 0x7E ) );
                                             <----------this blank controlled by -kgba
               return unless ($str);

       Blank lines have been introduced around the mmyy and uussee sequences.  What happened is that the default keyword
       list includes mmyy and uussee but not pprriinntt and rreettuurrnn.  So a continuous sequence of nine mmyy and uussee statements was
       located.  This number exceeds the default threshold of five, so blanks were placed before and after the entire
       group.  Then, since there was also a subsequence of six mmyy lines, a blank line was introduced to separate them.

       Finer control over blank placement can be achieved by using the individual parameters rather than the --kkggbb flag.
       The individual controls are as follows.

       --kkggbbll==ss or ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss--lliisstt==ss, where ss is a quoted string, defines the set of keywords which will be
       formed into groups.  The string is a space separated list of keywords.  The default set is ss==""uussee rreeqquuiirree llooccaall
       oouurr mmyy"", but any list of keywords may be used. Comment lines may also be included in a keyword group, even
       though they are not keywords.  To include ordinary block comments, include the symbol BBCC. To include static
       block comments (which normally begin with '##'), include the symbol SSBBCC.

       --kkggbbss==ss or ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss--ssiizzee==ss, where ss is a string describing the number of consecutive keyword
       statements forming a group.  If ss is an integer then it is the minimum number required for a group.  A maximum
       value may also be given with the format ss==mmiinn..mmaaxx, where mmiinn is the minimum number and mmaaxx is the maximum
       number, and the min and max values are separated by one or more dots.  No groups will be found if the maximum is
       less than the minimum.  The maximum is unlimited if not given.  The default is ss==55.  Some examples:

           s      min   max         number for group
           3      3     unlimited   3 or more
           1.1    1     1           1
           1..3   1     3           1 to 3
           1.0    1     0           (no match)

       --kkggbbbb==nn or ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss--bbeeffoorree==nn specifies whether a blank should appear before the first line of the
       group, as follows:

          n=0 => (delete) an existing blank line will be removed
          n=1 => (stable) no change to the input file is made  [DEFAULT]
          n=2 => (insert) a blank line is introduced if possible

       --kkggbbaa==nn or ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss--aafftteerr==nn likewise specifies whether a blank should appear after the last line
       of the group, using the same scheme (0=delete, 1=stable, 2=insert).

       --kkggbbii or ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss--iinnssiiddee controls the insertion of blank lines between the first and last
       statement of the entire group.  If there is a continuous run of a single statement type with more than the
       minimum threshold number (as specified with --kkggbbss==ss) then this switch causes a blank line be inserted between
       this subgroup and the others. In the example above this happened between the uussee and mmyy statements.

       --kkggbbdd or ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss--ddeelleettee controls the deletion of any blank lines that exist in the the group when
       it is first scanned.  When statements are initially scanned, any existing blank lines are included in the
       collection.  Any such orignial blank lines will be deleted before any other insertions are made when the
       parameter --kkggbbdd is set.  The default is not to do this, --nnkkggbbdd.

       --kkggbbrr==nn or ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss--rreeppeeaatt--ccoouunntt==nn specifies nn, the maximum number of times this logic will be
       applied to any file.  The special value nn==00 is the same as n=infinity which means it will be applied to an
       entire script [Default].  A value nn==11 could be used to make it apply just one time for example.  This might be
       useful for adjusting just the uussee statements in the top part of a module for example.

       --kkggbb or ----kkeeyywwoorrdd--ggrroouupp--bbllaannkkss is an abbreviation equivalent to setting --kkggbbbb==11 --kkggbbaa==11 --kkggbbii.  This turns on
       keyword group formatting with a set of default values.

       --nnkkggbb or ----nnookkeeyywwoorrdd--ggrroouupp--bbllaannkkss is equivalent to --kkggbbbb==00 --kkggbbaa nnkkggbbii.  This flag turns off keyword group blank
       lines and is the default setting.

       Here are a few notes about the functioning of this technique.

       +o   These parameters are probably more useful as part of a major code reformatting operation rather than as a
           routine formatting operation.

           In particular, note that deleting old blank lines with --kkggbbdd is an irreversible operation so it should be
           applied with care.  Existing blank lines may be serving an important role in controlling vertical alignment.

       +o   Conflicts which arise among these kkggbb** parameters and other blank line controls are generally resolved by
           producing the maximum number of blank lines implied by any parameter.

           For example, if the flags ----ffrreeeezzee--bbllaannkk--lliinneess, or ----kkeeeepp--oolldd--bbllaannkk--lliinneess==22, are set, then they have
           priority over any blank line deletion implied by the --kkggbb flags of this section, so no blank lines will be
           deleted.

           For another example, if a keyword group ends at a ssuubb and the flag kkggbbaa==00 requests no blank line there, but
           we also have ----bbllaannkk--lliinneess--bbeeffoorree--ssuubbss==22, then two blank lines will still be introduced before the sub.

       +o   The introduction of blank lines does not occur if it would conflict with other input controls or code
           validity. For example, a blank line will not be placed within a here-doc or within a section of code marked
           with format skipping comments.  And in general, a blank line will only be introduced at the end of a group
           if the next statement is a line of code.

       +o   The count which is used to determine the group size is not the number of lines but rather the total number
           of keywords which are found.  Individual statements with a certain leading keyword may continue on multiple
           lines, but if any of these lines is nested more than one level deep then that group will be ended.

       +o   The search for groups of lines with similar leading keywords is based on the input source, not the final
           formatted source.  Consequently, if the source code is badly formatted, it would be best to make a first
           formatting pass without these options.

   SSttyylleess
       A style refers to a convenient collection of existing parameters.

       --ggnnuu, ----ggnnuu--ssttyyllee
           --ggnnuu gives an approximation to the GNU Coding Standards (which do not apply to perl) as they are sometimes
           implemented.  At present, this style overrides the default style with the following parameters:

               -lp -bl -noll -pt=2 -bt=2 -sbt=2 -icp

       --ppbbpp, ----ppeerrll--bbeesstt--pprraaccttiicceess
           --ppbbpp is an abbreviation for the parameters in the book PPeerrll BBeesstt PPrraaccttiicceess by Damian Conway:

               -l=78 -i=4 -ci=4 -st -se -vt=2 -cti=0 -pt=1 -bt=1 -sbt=1 -bbt=1 -nsfs -nolq
               -wbb="% + - * / x != == >= <= =~ !~ < > | & =
                     **= += *= &= <<= &&= -= /= |= >>= ||= //= .= %= ^= x="

           Please note that this parameter set includes -st and -se flags, which make perltidy act as a filter on one
           file only.  These can be overridden by placing --nnsstt and/or --nnssee after the -pbp parameter.

           Also note that the value of continuation indentation, -ci=4, is equal to the value of the full indentation,
           -i=4.  It is recommended that the either (1) the parameter --ccii==22 be used instead, or the flag --xxccii be set.
           This will help show structure, particularly when there are ternary statements. The following snippet
           illustrates these options.

               # perltidy -pbp
               $self->{_text} = (
                    !$section        ? ''
                   : $type eq 'item' ? "the $section entry"
                   :                   "the section on $section"
                   )
                   . (
                   $page
                   ? ( $section ? ' in ' : '' ) . "the $page$page_ext manpage"
                   : ' elsewhere in this document'
                   );

               # perltidy -pbp -ci=2
               $self->{_text} = (
                    !$section        ? ''
                   : $type eq 'item' ? "the $section entry"
                   :                   "the section on $section"
                 )
                 . (
                   $page
                   ? ( $section ? ' in ' : '' ) . "the $page$page_ext manpage"
                   : ' elsewhere in this document'
                 );

               # perltidy -pbp -xci
               $self->{_text} = (
                    !$section        ? ''
                   : $type eq 'item' ? "the $section entry"
                   :                   "the section on $section"
                   )
                   . ( $page
                       ? ( $section ? ' in ' : '' ) . "the $page$page_ext manpage"
                       : ' elsewhere in this document'
                   );

           The --xxccii flag was developed after the --ppbbpp parameters were published so you need to include it separately.

       OOnnee--lliinnee bblloocckkss
           There are a few points to note regarding one-line blocks.  A one-line block is something like this,

           where the contents within the curly braces is short enough to fit on a single line.

           With few exceptions, perltidy retains existing one-line blocks, if it is possible within the line-length
           constraint, but it does not attempt to form new ones.  In other words, perltidy will try to follow the one-
           line block style of the input file.

           If an existing one-line block is longer than the maximum line length, however, it will be broken into
           multiple lines.  When this happens, perltidy checks for and adds any optional terminating semicolon (unless
           the --nnaasscc option is used) if the block is a code block.

           The main exception is that perltidy will attempt to form new one-line blocks following the keywords "map",
           "eval", and "sort", because these code blocks are often small and most clearly displayed in a single line.

           One-line block rules can conflict with the cuddled-else option.  When the cuddled-else option is used,
           perltidy retains existing one-line blocks, even if they do not obey cuddled-else formatting.

           Occasionally, when one-line blocks get broken because they exceed the available line length, the formatting
           will violate the requested brace style.  If this happens, reformatting the script a second time should
           correct the problem.

           Sometimes it might be desirable to convert a script to have one-line blocks whenever possible.  Although
           there is currently no flag for this, a simple workaround is to execute perltidy twice, once with the flag
           --nnooaadddd--nneewwlliinneess and then once again with normal parameters, like this:

                cat infile | perltidy -nanl | perltidy >outfile

           When executed on this snippet

               if ( $? == -1 ) {
                   die "failed to execute: $!\n";
               }
               if ( $? == -1 ) {
                   print "Had enough.\n";
                   die "failed to execute: $!\n";
               }

           the result is

               if ( $? == -1 ) { die "failed to execute: $!\n"; }
               if ( $? == -1 ) {
                   print "Had enough.\n";
                   die "failed to execute: $!\n";
               }

           This shows that blocks with a single statement become one-line blocks.

       --oollbbss==nn, ----oonnee--lliinnee--bblloocckk--sseemmiiccoolloonnss==nn
           This flag controls the placement of semicolons at the end of one-line blocks.  Semicolons are optional
           before a closing block brace, and frequently they are omitted at the end of a one-line block containing just
           a single statement.  By default, perltidy follows the input file regarding these semicolons, but this
           behavior can be controlled by this flag.  The values of n are:

             n=0 remove terminal semicolons in one-line blocks having a single statement
             n=1 stable; keep input file placement of terminal semicolons [DEFAULT ]
             n=2 add terminal semicolons in all one-line blocks

           Note that the nn==22 option has no effect if adding semicolons is prohibited with the --nnaasscc flag.  Also not
           that while nn==22 adds missing semicolons to all one-line blocks, regardless of complexity, the nn==00 option only
           removes ending semicolons which terminate one-line blocks containing just one semicolon.  So these two
           options are not exact inverses.

       --oollbbnn==nn, ----oonnee--lliinnee--bblloocckk--nneessttiinngg==nn
           Nested one-line blocks are lines with code blocks which themselves contain code blocks.  For example, the
           following line is a nested one-line block.

                    foreach (@list) { if ($_ eq $asked_for) { last } ++$found }

           The default behavior is to break such lines into multiple lines, but this behavior can be controlled with
           this flag.  The values of n are:

             n=0 break nested one-line blocks into multiple lines [DEFAULT]
             n=1 stable: keep existing nested-one line blocks intact

           For the above example, the default formatting (--oollbbnn==00) is

               foreach (@list) {
                   if ( $_ eq $asked_for ) { last }
                   ++$found;
               }

           If the parameter --oollbbnn==11 is given, then the line will be left intact if it is a single line in the source,
           or it will be broken into multiple lines if it is broken in multiple lines in the source.

   CCoonnttrroolllliinngg VVeerrttiiccaall AAlliiggnnmmeenntt
       Vertical alignment refers to lining up certain symbols in a list of consecutive similar lines to improve
       readability.  For example, the "fat commas" are aligned in the following statement:

               $data = $pkg->new(
                   PeerAddr => join( ".", @port[ 0 .. 3 ] ),
                   PeerPort => $port[4] * 256 + $port[5],
                   Proto    => 'tcp'
               );

       Vertical alignment can be completely turned off using --nnoovvaalliiggnn, a flag mainly intended for debugging.  However,
       vertical alignment can be forced to stop and restart by selectively introducing blank lines.  For example, a
       blank has been inserted in the following code to keep somewhat similar things aligned.

           %option_range = (
               'format'             => [ 'tidy', 'html', 'user' ],
               'output-line-ending' => [ 'dos',  'win',  'mac', 'unix' ],
               'character-encoding' => [ 'none', 'utf8' ],

               'block-brace-tightness'    => [ 0, 2 ],
               'brace-tightness'          => [ 0, 2 ],
               'paren-tightness'          => [ 0, 2 ],
               'square-bracket-tightness' => [ 0, 2 ],
           );

       Vertical alignment is implemented by locally increasing an existing blank space to produce alignment with an
       adjacent line.  It cannot occur if there is no blank space to increase.  So if a particular space is removed by
       one of the existing controls then vertical alignment cannot occur. Likewise, if a space is added with one of the
       controls, then vertical alignment might occur.

       For example,

               # perltidy -nwls='=>'
               $data = $pkg->new(
                   PeerAddr=> join( ".", @port[ 0 .. 3 ] ),
                   PeerPort=> $port[4] * 256 + $port[5],
                   Proto=> 'tcp'
               );

   OOtthheerr CCoonnttrroollss
       DDeelleettiinngg sseelleecctteedd tteexxtt
           Perltidy can selectively delete comments and/or pod documentation.  The command --ddaacc or
           ----ddeelleettee--aallll--ccoommmmeennttss will delete all comments aanndd all pod documentation, leaving just code and any leading
           system control lines.

           The command --ddpp or ----ddeelleettee--ppoodd will remove all pod documentation (but not comments).

           Two commands which remove comments (but not pod) are: --ddbbcc or ----ddeelleettee--bblloocckk--ccoommmmeennttss and --ddsscc or
           ----ddeelleettee--ssiiddee--ccoommmmeennttss.  (Hanging side comments will be deleted with side comments here.)

           The negatives of these commands also work, and are the defaults.  When block comments are deleted, any
           leading 'hash-bang' will be retained.  Also, if the --xx flag is used, any system commands before a leading
           hash-bang will be retained (even if they are in the form of comments).

       WWrriittiinngg sseelleecctteedd tteexxtt ttoo aa ffiillee
           When perltidy writes a formatted text file, it has the ability to also send selected text to a file with a
           _._T_E_E extension.  This text can include comments and pod documentation.

           The command --ttaacc or  ----tteeee--aallll--ccoommmmeennttss will write all comments aanndd all pod documentation.

           The command --ttpp or ----tteeee--ppoodd will write all pod documentation (but not comments).

           The commands which write comments (but not pod) are: --ttbbcc or ----tteeee--bblloocckk--ccoommmmeennttss and --ttsscc or
           ----tteeee--ssiiddee--ccoommmmeennttss.  (Hanging side comments will be written with side comments here.)

           The negatives of these commands also work, and are the defaults.

       UUssiinngg aa _.._pp_ee_rr_ll_tt_ii_dd_yy_rr_cc ccoommmmaanndd ffiillee
           If you use perltidy frequently, you probably won't be happy until you create a _._p_e_r_l_t_i_d_y_r_c file to avoid
           typing commonly-used parameters.  Perltidy will first look in your current directory for a command file
           named _._p_e_r_l_t_i_d_y_r_c.  If it does not find one, it will continue looking for one in other standard locations.

           These other locations are system-dependent, and may be displayed with the command "perltidy -dpro".  Under
           Unix systems, it will first look for an environment variable PPEERRLLTTIIDDYY.  Then it will look for a _._p_e_r_l_t_i_d_y_r_c
           file in the home directory, and then for a system-wide file _/_u_s_r_/_l_o_c_a_l_/_e_t_c_/_p_e_r_l_t_i_d_y_r_c, and then it will look
           for _/_e_t_c_/_p_e_r_l_t_i_d_y_r_c.  Note that these last two system-wide files do not have a leading dot.  Further system-
           dependent information will be found in the INSTALL file distributed with perltidy.

           Under Windows, perltidy will also search for a configuration file named perltidy.ini since Windows does not
           allow files with a leading period (.).  Use "perltidy -dpro" to see the possible locations for your system.
           An example might be _C_:_\_D_o_c_u_m_e_n_t_s _a_n_d _S_e_t_t_i_n_g_s_\_A_l_l _U_s_e_r_s_\_p_e_r_l_t_i_d_y_._i_n_i.

           Another option is the use of the PERLTIDY environment variable.  The method for setting environment
           variables depends upon the version of Windows that you are using.  Instructions for Windows 95 and later
           versions can be found here:

           http://www.netmanage.com/000/20021101_005_tcm21-6336.pdf

           Under Windows NT / 2000 / XP the PERLTIDY environment variable can be placed in either the user section or
           the system section.  The later makes the configuration file common to all users on the machine.  Be sure to
           enter the full path of the configuration file in the value of the environment variable.  Ex.
           PERLTIDY=C:\Documents and Settings\perltidy.ini

           The configuration file is free format, and simply a list of parameters, just as they would be entered on a
           command line.  Any number of lines may be used, with any number of parameters per line, although it may be
           easiest to read with one parameter per line.  Comment text begins with a #, and there must also be a space
           before the # for side comments.  It is a good idea to put complex parameters in either single or double
           quotes.

           Here is an example of a _._p_e_r_l_t_i_d_y_r_c file:

             # This is a simple of a .perltidyrc configuration file
             # This implements a highly spaced style
             -se    # errors to standard error output
             -w     # show all warnings
             -bl    # braces on new lines
             -pt=0  # parens not tight at all
             -bt=0  # braces not tight
             -sbt=0 # square brackets not tight

           The parameters in the _._p_e_r_l_t_i_d_y_r_c file are installed first, so any parameters given on the command line will
           have priority over them.

           To avoid confusion, perltidy ignores any command in the .perltidyrc file which would cause some kind of dump
           and an exit.  These are:

            -h -v -ddf -dln -dop -dsn -dtt -dwls -dwrs -ss

           There are several options may be helpful in debugging a _._p_e_r_l_t_i_d_y_r_c file:

           +o   A very helpful command is ----dduummpp--pprrooffiillee or --ddpprroo.  It writes a list of all configuration filenames
               tested to standard output, and if a file is found, it dumps the content to standard output before
               exiting.  So, to find out where perltidy looks for its configuration files, and which one if any it
               selects, just enter

                 perltidy -dpro

           +o   It may be simplest to develop and test configuration files with alternative names, and invoke them with
               --pprroo==ffiilleennaammee on the command line.  Then rename the desired file to _._p_e_r_l_t_i_d_y_r_c when finished.

           +o   The parameters in the _._p_e_r_l_t_i_d_y_r_c file can be switched off with the --nnpprroo option.

           +o   The commands ----dduummpp--ooppttiioonnss, ----dduummpp--ddeeffaauullttss, ----dduummpp--lloonngg--nnaammeess, and ----dduummpp--sshhoorrtt--nnaammeess, all described
               below, may all be helpful.

       CCrreeaattiinngg aa nneeww aabbbbrreevviiaattiioonn
           A special notation is available for use in a _._p_e_r_l_t_i_d_y_r_c file for creating an abbreviation for a group of
           options.  This can be used to create a shorthand for one or more styles which are frequently, but not
           always, used.  The notation is to group the options within curly braces which are preceded by the name of
           the alias (without leading dashes), like this:

                   newword {
                   -opt1
                   -opt2
                   }

           where nneewwwwoorrdd is the abbreviation, and oopptt11, etc, are existing parameters _o_r _o_t_h_e_r _a_b_b_r_e_v_i_a_t_i_o_n_s.  The main
           syntax requirement is that the new abbreviation along with its opening curly brace must begin on a new line.
           Space before and after the curly braces is optional.

           For a specific example, the following line

                   oneliner { --maximum-line-length=0 --noadd-newlines --noadd-terminal-newline}

           or equivalently with abbreviations

                   oneliner { -l=0 -nanl -natnl }

           could be placed in a _._p_e_r_l_t_i_d_y_r_c file to temporarily override the maximum line length with a large value, to
           temporarily prevent new line breaks from being added, and to prevent an extra newline character from being
           added the file.  All other settings in the _._p_e_r_l_t_i_d_y_r_c file still apply.  Thus it provides a way to format a
           long 'one liner' when perltidy is invoked with

                   perltidy --oneliner ...

           (Either "-oneliner" or "--oneliner" may be used).

       Skipping leading non-perl commands with --xx or ----llooookk--ffoorr--hhaasshh--bbaanngg
           If your script has leading lines of system commands or other text which are not valid perl code, and which
           are separated from the start of the perl code by a "hash-bang" line, ( a line of the form "#!...perl" ), you
           must use the --xx flag to tell perltidy not to parse and format any lines before the "hash-bang" line.  This
           option also invokes perl with a -x flag when checking the syntax.  This option was originally added to allow
           perltidy to parse interactive VMS scripts, but it should be used for any script which is normally invoked
           with "perl -x".

           Please note: do not use this flag unless you are sure your script needs it.  Parsing errors can occur if it
           does not have a hash-bang, or, for example, if the actual first hash-bang is in a here-doc. In that case a
           parsing error will occur because the tokenization will begin in the middle of the here-doc.

       MMaakkiinngg aa ffiillee uunnrreeaaddaabbllee
           The goal of perltidy is to improve the readability of files, but there are two commands which have the
           opposite effect, ----mmaannggllee and ----eexxttrruuddee.  They are actually merely aliases for combinations of other
           parameters.  Both of these strip all possible whitespace, but leave comments and pod documents, so that they
           are essentially reversible.  The difference between these is that ----mmaannggllee puts the fewest possible line
           breaks in a script while ----eexxttrruuddee puts the maximum possible.  Note that these options do not provided any
           meaningful obfuscation, because perltidy can be used to reformat the files.  They were originally developed
           to help test the tokenization logic of perltidy, but they have other uses.  One use for ----mmaannggllee is the
           following:

             perltidy --mangle myfile.pl -st | perltidy -o myfile.pl.new

           This will form the maximum possible number of one-line blocks (see next section), and can sometimes help
           clean up a badly formatted script.

           A similar technique can be used with ----eexxttrruuddee instead of ----mmaannggllee to make the minimum number of one-line
           blocks.

           Another use for ----mmaannggllee is to combine it with --ddaacc to reduce the file size of a perl script.

       DDeebbuuggggiinngg
           The following flags are available for debugging:

           ----dduummpp--ccuuddddlleedd--bblloocckk--lliisstt or --ddccbbll will dump to standard output the internal hash of cuddled block types
           created by a --ccuuddddlleedd--bblloocckk--lliisstt input string.

           ----dduummpp--ddeeffaauullttss or --ddddff will write the default option set to standard output and quit

           ----dduummpp--pprrooffiillee or --ddpprroo  will write the name of the current configuration file and its contents to standard
           output and quit.

           ----dduummpp--ooppttiioonnss or --ddoopp  will write current option set to standard output and quit.

           ----dduummpp--lloonngg--nnaammeess or --ddllnn  will write all command line long names (passed to Get_options) to standard output
           and quit.

           ----dduummpp--sshhoorrtt--nnaammeess  or --ddssnn will write all command line short names to standard output and quit.

           ----dduummpp--ttookkeenn--ttyyppeess or --ddtttt  will write a list of all token types to standard output and quit.

           ----dduummpp--wwaanntt--lleefftt--ssppaaccee or --ddwwllss  will write the hash %want_left_space to standard output and quit.  See the
           section on controlling whitespace around tokens.

           ----dduummpp--wwaanntt--rriigghhtt--ssppaaccee or --ddwwrrss  will write the hash %want_right_space to standard output and quit.  See
           the section on controlling whitespace around tokens.

           ----nnoo--mmeemmooiizzee or --nnmmeemm  will turn of memoizing.  Memoization can reduce run time when running perltidy
           repeatedly in a single process.  It is on by default but can be deactivated for testing with --nnmmeemm.

           ----nnoo--ttiimmeessttaammpp or --nnttss will eliminate any time stamps in output files to prevent differences in dates from
           causing test installation scripts to fail. There are just a couple of places where timestamps normally
           occur. One is in the headers of html files, and another is when the --ccssccww option is selected. The default is
           to allow timestamps (----ttiimmeessttaammpp or --ttss).

           ----ffiillee--ssiizzee--oorrddeerr or --ffssoo will cause files to be processed in order of increasing size, when multiple files
           are being processed.  This is useful during program development, when large numbers of files with varying
           sizes are processed, because it can reduce virtual memory usage.

           ----mmaaxxiimmuumm--ffiillee--ssiizzee--mmbb==nn or --mmaaxxffss==nn specifies the maximum file size in megabytes that perltidy will attempt
           to format. This parameter is provided to avoid causing system problems by accidentally attempting to format
           an extremely large data file. Most perl scripts are less than about 2 MB in size. The integer nn has a
           default value of 10, so perltidy will skip formatting files which have a size greater than 10 MB.  The
           command to increase the limit to 20 MB for example would be

             perltidy -maxfs=20

           This only applies to files specified by filename on the command line.

           ----mmaaxxiimmuumm--lleevveell--eerrrroorrss==nn or --mmaaxxllee==nn specifies the maximum number of indentation level errors are allowed
           before perltidy skips formatting and just outputs a file verbatim.  The default is nn==11.  This means that if
           the final indentation of a script differs from the starting indentation by more than 1 levels, the file will
           be output verbatim.  To avoid formatting if there are any indentation level errors use -maxle=0. To skip
           this check you can either set n equal to a large number, such as nn==110000, or set nn==--11.

           For example, the following script has level error of 3 and will be output verbatim

               Input and default output:
               {{{

               perltidy -maxle=100
               {
                   {
                       {

           ----mmaaxxiimmuumm--uunneexxppeecctteedd--eerrrroorrss==nn or --mmaaxxuuee==nn specifies the maximum number of unexpected tokenization errors are
           allowed before formatting is skipped and a script is output verbatim.  The intention is to avoid
           accidentally formatting a non-perl script, such as an html file for example.  This check can be turned off
           by setting nn==00.

           A recommended value is nn==33.  However, the default is nn==00 (skip this check) to avoid causing problems with
           scripts which have extended syntaxes.

           --DDEEBBUUGG  will write a file with extension _._D_E_B_U_G for each input file showing the tokenization of all lines of
           code.

       WWoorrkkiinngg wwiitthh MMaakkeeMMaakkeerr,, AAuuttooLLooaaddeerr aanndd SSeellffLLooaaddeerr
           The first $VERSION line of a file which might be eval'd by MakeMaker is passed through unchanged except for
           indentation.  Use ----nnooppaassss--vveerrssiioonn--lliinnee, or --nnppvvll, to deactivate this feature.

           If the AutoLoader module is used, perltidy will continue formatting code after seeing an __END__ line.  Use
           ----nnoollooookk--ffoorr--aauuttoollooaaddeerr, or --nnllaall, to deactivate this feature.

           Likewise, if the SelfLoader module is used, perltidy will continue formatting code after seeing a __DATA__
           line.  Use ----nnoollooookk--ffoorr--sseellffllooaaddeerr, or --nnllssll, to deactivate this feature.

       WWoorrkkiinngg aarroouunndd pprroobblleemmss wwiitthh oollddeerr vveerrssiioonn ooff PPeerrll
           Perltidy contains a number of rules which help avoid known subtleties and problems with older versions of
           perl, and these rules always take priority over whatever formatting flags have been set.  For example,
           perltidy will usually avoid starting a new line with a bareword, because this might cause problems if "use
           strict" is active.

           There is no way to override these rules.

HHTTMMLL OOPPTTIIOONNSS
       The --hhttmmll master switch
           The flag --hhttmmll causes perltidy to write an html file with extension _._h_t_m_l.  So, for example, the following
           command

                   perltidy -html somefile.pl

           will produce a syntax-colored html file named _s_o_m_e_f_i_l_e_._p_l_._h_t_m_l which may be viewed with a browser.

           PPlleeaassee NNoottee: In this case, perltidy does not do any formatting to the input file, and it does not write a
           formatted file with extension _._t_d_y.  This means that two perltidy runs are required to create a fully
           reformatted, html copy of a script.

       The --pprree flag for code snippets
           When the --pprree flag is given, only the pre-formatted section, within the <PRE> and </PRE> tags, will be
           output.  This simplifies inclusion of the output in other files.  The default is to output a complete web
           page.

       The --nnnnnn flag for line numbering
           When the --nnnnnn flag is given, the output lines will be numbered.

       The --ttoocc, or ----hhttmmll--ttaabbllee--ooff--ccoonntteennttss flag
           By default, a table of contents to packages and subroutines will be written at the start of html output.
           Use --nnttoocc to prevent this.  This might be useful, for example, for a pod document which contains a number of
           unrelated code snippets.  This flag only influences the code table of contents; it has no effect on any
           table of contents produced by pod2html (see next item).

       The --ppoodd, or ----ppoodd22hhttmmll flag
           There are two options for formatting pod documentation.  The default is to pass the pod through the
           Pod::Html module (which forms the basis of the pod2html utility).  Any code sections are formatted by
           perltidy, and the results then merged.  Note: perltidy creates a temporary file when Pod::Html is used; see
           "FILES".  Also, Pod::Html creates temporary files for its cache.

           NOTE: Perltidy counts the number of "=cut" lines, and either moves the pod text to the top of the html file
           if there is one "=cut", or leaves the pod text in its original order (interleaved with code) otherwise.

           Most of the flags accepted by pod2html may be included in the perltidy command line, and they will be passed
           to pod2html.  In some cases, the flags have a prefix "pod" to emphasize that they are for the pod2html, and
           this prefix will be removed before they are passed to pod2html.  The flags which have the additional "pod"
           prefix are:

              --[no]podheader --[no]podindex --[no]podrecurse --[no]podquiet
              --[no]podverbose --podflush

           The flags which are unchanged from their use in pod2html are:

              --backlink=s --cachedir=s --htmlroot=s --libpods=s --title=s
              --podpath=s --podroot=s

           where 's' is an appropriate character string.  Not all of these flags are available in older versions of
           Pod::Html.  See your Pod::Html documentation for more information.

           The alternative, indicated with --nnppoodd, is not to use Pod::Html, but rather to format pod text in italics (or
           whatever the stylesheet indicates), without special html markup.  This is useful, for example, if pod is
           being used as an alternative way to write comments.

       The --ffrrmm, or ----ffrraammeess flag
           By default, a single html output file is produced.  This can be changed with the --ffrrmm option, which creates
           a frame holding a table of contents in the left panel and the source code in the right side. This simplifies
           code browsing.  Assume, for example, that the input file is _M_y_M_o_d_u_l_e_._p_m.  Then, for default file extension
           choices, these three files will be created:

            MyModule.pm.html      - the frame
            MyModule.pm.toc.html  - the table of contents
            MyModule.pm.src.html  - the formatted source code

           Obviously this file naming scheme requires that output be directed to a real file (as opposed to, say,
           standard output).  If this is not the case, or if the file extension is unknown, the --ffrrmm option will be
           ignored.

       The --tteexxtt==ss, or ----hhttmmll--ttoocc--eexxtteennssiioonn flag
           Use this flag to specify the extra file extension of the table of contents file when html frames are used.
           The default is "toc".  See "Specifying File Extensions".

       The --sseexxtt==ss, or ----hhttmmll--ssrrcc--eexxtteennssiioonn flag
           Use this flag to specify the extra file extension of the content file when html frames are used.  The
           default is "src".  See "Specifying File Extensions".

       The --hheenntt, or ----hhttmmll--eennttiittiieess flag
           This flag controls the use of Html::Entities for html formatting.  By default, the module Html::Entities is
           used to encode special symbols.  This may not be the right thing for some browser/language combinations.
           Use --nohtml-entities or -nhent to prevent this.

       SSttyyllee SShheeeettss
           Style sheets make it very convenient to control and adjust the appearance of html pages.  The default
           behavior is to write a page of html with an embedded style sheet.

           An alternative to an embedded style sheet is to create a page with a link to an external style sheet.  This
           is indicated with the --ccssss==ffiilleennaammee,  where the external style sheet is _f_i_l_e_n_a_m_e.  The external style sheet
           _f_i_l_e_n_a_m_e will be created if and only if it does not exist.  This option is useful for controlling multiple
           pages from a single style sheet.

           To cause perltidy to write a style sheet to standard output and exit, use the --ssss, or ----ssttyylleesshheeeett, flag.
           This is useful if the style sheet could not be written for some reason, such as if the --pprree flag was used.
           Thus, for example,

             perltidy -html -ss >mystyle.css

           will write a style sheet with the default properties to file _m_y_s_t_y_l_e_._c_s_s.

           The use of style sheets is encouraged, but a web page without a style sheets can be created with the flag
           --nnssss.  Use this option if you must to be sure that older browsers (roughly speaking, versions prior to 4.0
           of Netscape Navigator and Internet Explorer) can display the syntax-coloring of the html files.

       CCoonnttrroolllliinngg HHTTMMLL pprrooppeerrttiieess
           Note: It is usually more convenient to accept the default properties and then edit the stylesheet which is
           produced.  However, this section shows how to control the properties with flags to perltidy.

           Syntax colors may be changed from their default values by flags of the either the long form,
           --hhttmmll--ccoolloorr--xxxxxxxxxxxx==nn, or more conveniently the short form, --hhccxx==nn, where xxxxxxxxxxxx is one of the following
           words, and xx is the corresponding abbreviation:

                 Token Type             xxxxxx           x
                 ----------             --------         --
                 comment                comment          c
                 number                 numeric          n
                 identifier             identifier       i
                 bareword, function     bareword         w
                 keyword                keyword          k
                 quite, pattern         quote            q
                 here doc text          here-doc-text    h
                 here doc target        here-doc-target  hh
                 punctuation            punctuation      pu
                 parentheses            paren            p
                 structural braces      structure        s
                 semicolon              semicolon        sc
                 colon                  colon            co
                 comma                  comma            cm
                 label                  label            j
                 sub definition name    subroutine       m
                 pod text               pod-text         pd

           A default set of colors has been defined, but they may be changed by providing values to any of the
           following parameters, where nn is either a 6 digit hex RGB color value or an ascii name for a color, such as
           'red'.

           To illustrate, the following command will produce an html file _s_o_m_e_f_i_l_e_._p_l_._h_t_m_l with "aqua" keywords:

                   perltidy -html -hck=00ffff somefile.pl

           and this should be equivalent for most browsers:

                   perltidy -html -hck=aqua somefile.pl

           Perltidy merely writes any non-hex names that it sees in the html file.  The following 16 color names are
           defined in the HTML 3.2 standard:

                   black   => 000000,
                   silver  => c0c0c0,
                   gray    => 808080,
                   white   => ffffff,
                   maroon  => 800000,
                   red     => ff0000,
                   purple  => 800080,
                   fuchsia => ff00ff,
                   green   => 008000,
                   lime    => 00ff00,
                   olive   => 808000,
                   yellow  => ffff00
                   navy    => 000080,
                   blue    => 0000ff,
                   teal    => 008080,
                   aqua    => 00ffff,

           Many more names are supported in specific browsers, but it is safest to use the hex codes for other colors.
           Helpful color tables can be located with an internet search for "HTML color tables".

           Besides color, two other character attributes may be set: bold, and italics.  To set a token type to use
           bold, use the flag ----hhttmmll--bboolldd--xxxxxxxxxxxx or --hhbbxx, where xxxxxxxxxxxx or xx are the long or short names from the above
           table.  Conversely, to set a token type to NOT use bold, use ----nnoohhttmmll--bboolldd--xxxxxxxxxxxx or --nnhhbbxx.

           Likewise, to set a token type to use an italic font, use the flag ----hhttmmll--iittaalliicc--xxxxxxxxxxxx or --hhiixx, where again
           xxxxxxxxxxxx or xx are the long or short names from the above table.  And to set a token type to NOT use italics,
           use ----nnoohhttmmll--iittaalliicc--xxxxxxxxxxxx or --nnhhiixx.

           For example, to use bold braces and lime color, non-bold, italics keywords the following command would be
           used:

                   perltidy -html -hbs -hck=00FF00 -nhbk -hik somefile.pl

           The background color can be specified with ----hhttmmll--ccoolloorr--bbaacckkggrroouunndd==nn, or --hhccbbgg==nn for short, where n is a 6
           character hex RGB value.  The default color of text is the value given to ppuunnccttuuaattiioonn, which is black as a
           default.

           Here are some notes and hints:

           1. If you find a preferred set of these parameters, you may want to create a _._p_e_r_l_t_i_d_y_r_c file containing
           them.  See the perltidy man page for an explanation.

           2. Rather than specifying values for these parameters, it is probably easier to accept the defaults and then
           edit a style sheet.  The style sheet contains comments which should make this easy.

           3. The syntax-colored html files can be very large, so it may be best to split large files into smaller
           pieces to improve download times.

SSOOMMEE CCOOMMMMOONN IINNPPUUTT CCOONNVVEENNTTIIOONNSS
   SSppeecciiffyyiinngg BBlloocckk TTyyppeess
       Several parameters which refer to code block types may be customized by also specifying an associated list of
       block types.  The type of a block is the name of the keyword which introduces that block, such as iiff, eellssee, or
       ssuubb.  An exception is a labeled block, which has no keyword, and should be specified with just a colon.  To
       specify all blocks use ''**''.

       The keyword ssuubb indicates a named sub.  For anonymous subs, use the special keyword aassuubb.

       For example, the following parameter specifies "sub", labels, "BEGIN", and "END" blocks:

          -cscl="sub : BEGIN END"

       (the meaning of the -cscl parameter is described above.)  Note that quotes are required around the list of block
       types because of the spaces.  For another example, the following list specifies all block types for vertical
       tightness:

          -bbvtl='*'

   SSppeecciiffyyiinngg FFiillee EExxtteennssiioonnss
       Several parameters allow default file extensions to be overridden.  For example, a backup file extension may be
       specified with --bbeexxtt==eexxtt, where eexxtt is some new extension.  In order to provides the user some flexibility, the
       following convention is used in all cases to decide if a leading '.' should be used.  If the extension "ext"
       begins with "A-Z", "a-z", or "0-9", then it will be appended to the filename with an intermediate '.' (or
       perhaps a '_' on VMS systems).  Otherwise, it will be appended directly.

       For example, suppose the file is _s_o_m_e_f_i_l_e_._p_l.  For "-bext=old", a '.' is added to give _s_o_m_e_f_i_l_e_._p_l_._o_l_d.  For
       "-bext=.old", no additional '.' is added, so again the backup file is _s_o_m_e_f_i_l_e_._p_l_._o_l_d.  For "-bext=~", then no
       dot is added, and the backup file will be _s_o_m_e_f_i_l_e_._p_l_~  .

SSWWIITTCCHHEESS WWHHIICCHH MMAAYY BBEE NNEEGGAATTEEDD
       The following list shows all short parameter names which allow a prefix 'n' to produce the negated form:

        D      anl    asbl   asc    ast    asu    atnl   aws    b      baa
        baao   bar    bbao   bbb    bbc    bbs    bl     bli    boa    boc
        bok    bol    bom    bos    bot    cblx   ce     conv   cs     csc
        cscb   cscw   dac    dbc    dcbl   dcsc   ddf    dln    dnl    dop
        dp     dpro   dsc    dsm    dsn    dtt    dwls   dwrs   dws    f
        fll    fpva   frm    fs     fso    gcs    hbc    hbcm   hbco   hbh
        hbhh   hbi    hbj    hbk    hbm    hbn    hbp    hbpd   hbpu   hbq
        hbs    hbsc   hbv    hbw    hent   hic    hicm   hico   hih    hihh
        hii    hij    hik    him    hin    hip    hipd   hipu   hiq    his
        hisc   hiv    hiw    hsc    html   ibc    icb    icp    iob    isbc
        iscl   kgb    kgbd   kgbi   kis    lal    log    lop    lp     lsl
        mem    nib    ohbr   okw    ola    olc    oll    olq    opr    opt
        osbc   osbr   otr    ple    pod    pvl    q      sac    sbc    sbl
        scbb   schb   scp    scsb   sct    se     sfp    sfs    skp    sob
        sobb   sohb   sop    sosb   sot    ssc    st     sts    t      tac
        tbc    toc    tp     tqw    trp    ts     tsc    tso    vmll   w
        wn     x      xci    xs

       Equivalently, the prefix 'no' or 'no-' on the corresponding long names may be used.

LLIIMMIITTAATTIIOONNSS
       PPaarrssiinngg LLiimmiittaattiioonnss
           Perltidy should work properly on most perl scripts.  It does a lot of self-checking, but still, it is
           possible that an error could be introduced and go undetected.  Therefore, it is essential to make careful
           backups and to test reformatted scripts.

           The main current limitation is that perltidy does not scan modules included with 'use' statements.  This
           makes it necessary to guess the context of any bare words introduced by such modules.  Perltidy has good
           guessing algorithms, but they are not infallible.  When it must guess, it leaves a message in the log file.

           If you encounter a bug, please report it.

       WWhhaatt ppeerrllttiiddyy ddooeess nnoott ppaarrssee aanndd ffoorrmmaatt
           Perltidy indents but does not reformat comments and "qw" quotes.  Perltidy does not in any way modify the
           contents of here documents or quoted text, even if they contain source code.  (You could, however, reformat
           them separately).  Perltidy does not format 'format' sections in any way.  And, of course, it does not
           modify pod documents.

FFIILLEESS
       TTeemmppoorraarryy ffiilleess
           Under the -html option with the default --pod2html flag, a temporary file is required to pass text to
           Pod::Html.  Unix systems will try to use the POSIX ttmmppnnaamm(()) function.  Otherwise the file _p_e_r_l_t_i_d_y_._T_M_P will
           be temporarily created in the current working directory.

       SSppeecciiaall ffiilleess wwhheenn ssttaannddaarrdd iinnppuutt iiss uusseedd
           When standard input is used, the log file, if saved, is _p_e_r_l_t_i_d_y_._L_O_G, and any errors are written to
           _p_e_r_l_t_i_d_y_._E_R_R unless the --ssee flag is set.  These are saved in the current working directory.

       FFiilleess oovveerrwwrriitttteenn
           The following file extensions are used by perltidy, and files with these extensions may be overwritten or
           deleted: _._E_R_R, _._L_O_G, _._T_E_E, and/or _._t_d_y, _._h_t_m_l, and _._b_a_k, depending on the run type and settings.

       FFiilleess eexxtteennssiioonnss lliimmiittaattiioonnss
           Perltidy does not operate on files for which the run could produce a file with a duplicated file extension.
           These extensions include _._L_O_G, _._E_R_R, _._T_E_E, and perhaps _._t_d_y and _._b_a_k, depending on the run type.  The
           purpose of this rule is to prevent generating confusing filenames such as _s_o_m_e_f_i_l_e_._t_d_y_._t_d_y_._t_d_y.

EERRRROORR HHAANNDDLLIINNGG
       An exit value of 0, 1, or 2 is returned by perltidy to indicate the status of the result.

       A exit value of 0 indicates that perltidy ran to completion with no error messages.

       A non-zero exit value indicates some kind of problem was detected.

       An exit value of 1 indicates that perltidy terminated prematurely, usually due to some kind of errors in the
       input parameters.  This can happen for example if a parameter is misspelled or given an invalid value.  Error
       messages in the standard error output will indicate the cause of any problem.  If perltidy terminates
       prematurely then no output files will be produced.

       An exit value of 2 indicates that perltidy was able to run to completion but there there are (1) warning
       messages in the standard error output related to parameter errors or problems and/or (2) warning messages in the
       perltidy error file(s) relating to possible syntax errors in one or more of the source script(s) being tidied.
       When multiple files are being processed, an error detected in any single file will produce this type of exit
       condition.

SSEEEE AALLSSOO
       ppeerrllssttyyllee(1), PPeerrll::::TTiiddyy(3)

IINNSSTTAALLLLAATTIIOONN
       The perltidy binary uses the Perl::Tidy module and is installed when that module is installed.  The module name
       is case-sensitive.  For example, the basic command for installing with cpanm is 'cpanm Perl::Tidy'.

VVEERRSSIIOONN
       This man page documents perltidy version 20210717

BBUUGG RREEPPOORRTTSS
       A list of current bugs and issues can be found at the CPAN site
       <https://rt.cpan.org/Public/Dist/Display.html?Name=Perl-Tidy>

       To report a new bug or problem, use the link on this page.

       The source code repository is at <https://github.com/perltidy/perltidy>.

CCOOPPYYRRIIGGHHTT
       Copyright (c) 2000-2021 by Steve Hancock

LLIICCEENNSSEE
       This package is free software; you can redistribute it and/or modify it under the terms of the "GNU General
       Public License".

       Please refer to the file "COPYING" for details.

DDIISSCCLLAAIIMMEERR
       This package is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
       implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

       See the "GNU General Public License" for more details.

perl v5.22.1                                           2021-07-15                                           PERLTIDY(1)
