# Perlcritic is a very useful tool for locating potential code problems.
# This file customizes it to the specific needs of Perl::Tidy.

# Some useful links:
# https://manpages.ubuntu.com/manpages/xenial/man1/perlcritic.1p.html
# https://perlmaven.com/perl-critic

# Example command to run a single policy on single module:
# perlcritic --single-policy Subroutines::ProhibitSubroutinePrototypes Module.pm

# Many of the policies are excellent starting points for new code, but
# important exceptions often exist which make it impossible to use them as
# rigid rules. I have found that using 'no critic' comments is much too
# troublesome, so non-configurable policies which have exceptions must be
# turned off.  This file lists the policies which must be turned off for
# Perl::Tidy, at least for now.

# severity = 1 gives the most strict checking.
severity = 1

verbose = %f: [%p] %m at line %l, column %c.\n

#--------------------------------------------------------------
# Following is a list of policies to be skipped for severity=4:
#--------------------------------------------------------------

# There is a localization in Tokenizer.pm that is essential for recursion
[-Variables::ProhibitLocalVars] 

# Immediate initialization of locals is not appropriate where used
# in the Tokenizer.pm module
[-Variables::RequireInitializationForLocalVars] 

# There is a stringy eval in Formatter.pm and Tokenizer.pm which is essential
# for checking user input. So we have to skip this.  I would have liked
# to mark it with a nocritic side comment, but see note above for the trouble
# this causes.
[-BuiltinFunctions::ProhibitStringyEval]

# Tidy.pm exports 'perltidy'. Changing this could break existing scripts.
[-Modules::ProhibitAutomaticExportation]

# 'print' and 'close' homonyms are appropriate where they are used.
[-Subroutines::ProhibitBuiltinHomonyms]

# Nested subs are used for error handling in Tidy.pm.
[-Subroutines::ProhibitNestedSubs]

# Don't require arg unpacking for very short (possibly time-critical) subs.
[Subroutines::RequireArgUnpacking]
short_subroutine_statements = 2

# Completely Disagree: The advantages of 'use constant' greatly outweigh the
# few disadvantages.  Perl::Tidy relies heavily on constants for efficient and
# robust coding of array indexes and for compiling out debug code, and to
# avoid autovivication problems that would occur if hashes were used instead.
[-ValuesAndExpressions::ProhibitConstantPragma]

# Completely Disagree: adding quotes on here doc terminators causes needless
# "line noise" in the source code.  Almost always the default works.  Besides,
# my editor uses color to make it clear if interpolation is in effect.
[-ValuesAndExpressions::RequireQuotedHeredocTerminator]

# Perlcritic doesn't know that ARGV in Perl::Tidy actually is localized.
# Localization of @ARGV could be avoided by calling GetOptionsFromArray
# instead of GetOptions, but that is not available before perl 5.10, and
# we want to continue supporting Perl 5.8. So we have to skip this for now.
# When the time comes to make perl 5.10 the earliest version supported,
# this can be fixed.
[-Variables::RequireLocalizedPunctuationVars]

# Unfortunately the perlcritic coding for this policy is buggy when lines=n is
# specified.  For example if I use lines=n to increase 'n' above the default of
# 9, then suddenly I get error messages for code which previously passed with
# the default. So we have to skip this.
[-InputOutput::RequireBriefOpen]

#--------------------------------------------------------------
# Following is a list of policies to be skipped for severity=3:
#--------------------------------------------------------------

# AUTOLOAD is used in perltidy to help find and debug programming errors.
# This is very useful, so we have to skip this.
[-ClassHierarchies::ProhibitAutoloading]

# This policy is very useful in locating complex code which might benefit from
# simplification.  The max value has to be set rather high here because there
# are some critical loops in Formatter.pm whose high mccabe values cannot
# be reduced without significantly increasing run time.
[Subroutines::ProhibitExcessComplexity]
max_mccabe=180

# This policy can be very helpful for locating complex code, but sometimes
# deep nests are the best option, especially in error handling and debug
# coding. So a large value is used here.
[ControlStructures::ProhibitDeepNests]
max_nests=9

# This would be nice, but there are many cases where this is really impossible.
[-ControlStructures::ProhibitCascadingIfElse]

# This is a reasonable starting point but does not work well as a rigid rule.
[-ControlStructures::ProhibitNegativeExpressionsInUnlessAndUntilConditions]

# This is a good general policy but not always possible in time-critical subs
[-Subroutines::ProhibitManyArgs]

[-ClassHierarchies::ProhibitExplicitISA]

# These are okay where used
[-NamingConventions::ProhibitAmbiguousNames]

# I find that using lvalue substr much clearer than adding another arg to
# substr.  So skip this one.
[-BuiltinFunctions::ProhibitLvalueSubstr]

# These would be okay for new code, but do not change any debugged regular
# expressions without good reason.  It is too easy to introduce a subtle error.
# A problem with ReqireExtendedFormatting is that it makes things needlessly
# complex when matching things like line feeds and carriage returns.
[-RegularExpressions::RequireExtendedFormatting]
[-RegularExpressions::ProhibitComplexRegexes]
[-RegularExpressions::ProhibitUnusedCapture]
[-RegularExpressions::ProhibitCaptureWithoutTest]

#--------------------------------------------------------------
# Following is a list of policies to be skipped for severity=2:
#--------------------------------------------------------------

# Disagree. In fact, following this policy caused a parsing error in Perl
# version 5.14 at file test operators.  So skip this because it can cause
# loss of code robustness.
[-BuiltinFunctions::ProhibitUselessTopic]

# These would be okay for new code, but do not change any debugged regular
# expressions without good reason.  It is too easy to introduce a subtle error.
[-RegularExpressions::RequireDotMatchAnything]
[-RegularExpressions::RequireLineBoundaryMatching]

# This is another one of those rules which often works but not always. Is '#'
# really harder to read than q{#}?  And in tokenization code it is often
# necessary to work with symbols like '{' '}' '<' and so on.  So we would need
# q<{> q<}> q{<} and so on, which is hard on the eyes. Also, sometimes
# perlcritic is inconsistent regarding this rule because sometimes wants to
# apply this rule to hash keys, and sometimes not.
[-ValuesAndExpressions::ProhibitNoisyQuotes]

# In some cases a postfix control shows the logical flow most clearly.
# For example, I find this easier to read:

#    $self->weld_cuddled_blocks()
#       if ( %{$rcuddled_block_types} );

# than this:

#    if ( %{$rcuddled_block_types} ) {
#       $self->weld_cuddled_blocks()
#    }

# The extra braces just add clutter.

[-ControlStructures::ProhibitPostfixControls]

# Sometimes an unless statement is clearer than an if block, so why not use
# it?  For example, I might prefer the first of these:

#  return unless ($everything_is_ok);
# vs.
#  return if (!$everything_is_ok);
[-ControlStructures::ProhibitUnlessBlocks]

# This is a good general idea but has to be turned off because there are many
# cases where a number has been explained in a comment or is obvious.
[-ValuesAndExpressions::ProhibitMagicNumbers]

#--------------------------------------------------------------
# Following is a list of policies to be skipped for severity=1:
#--------------------------------------------------------------

# This is a good starting rule, but occasional capitalization can be quite
# effective or appropriate for marking a special variable, so we have to ignore
# it as a general rule:
[-NamingConventions::Capitalization]

# PerlCritic should not suggest this policy for complex sorts because it can
# change program behavior when a stable sort has been assumed.  And it does not
# even make sense for sorts on multiple keys, like this one which got flagged
# in Perl::Tidy
#        @candidates =
#          sort { $b->[1] <=> $a->[1] || $a->[0] <=> $b->[0] } @candidates;
# Changing the first part requires changing the second part, so either way
# you have a comparison of the form $b->[*] <=> $a->[*]. So skip this.
[-BuiltinFunctions::ProhibitReverseSortBlock]

# These would be okay for new code, but do not change any debugged regular
# expressions without good reason.  It is too easy to introduce a subtle error.
[-RegularExpressions::ProhibitEscapedMetacharacters]
[-RegularExpressions::ProhibitEnumeratedClasses]
[-RegularExpressions::ProhibitUnusualDelimiters]
[-RegularExpressions::ProhibitSingleCharAlternation]
[-RegularExpressions::RequireBracesForMultiline]
[-RegularExpressions::ProhibitSingleCharAlternation]

# Disagree. Double quotes are easier to read than single quotes and allow a
# uniform style for quotes.  My editor has color coding which indicates
# interpolation. Double quotes do not increase processing time by any
# measurable amount.  Using them as default simplfies making editing changes.
# So skip this:
[-ValuesAndExpressions::ProhibitInterpolationOfLiterals]

# These have been checked and are correct as written 
[-ValuesAndExpressions::RequireInterpolationOfMetachars]

# Disagree: parens can add clarity and may even be essential, for example in
# ternary expressions. There is little to be gained by omitting them.
[-CodeLayout::ProhibitParensWithBuiltins] 

# This is OK if we exclude 'print'. Most of the 'print' statements
# in perltidy are for error reporting, and it does not help to add
# more extra error checks on top of them. 
[InputOutput::RequireCheckedSyscalls]
exclude_functions = print
